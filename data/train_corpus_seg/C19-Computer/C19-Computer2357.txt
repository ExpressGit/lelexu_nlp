计算机 研究 与 发展 
 JOURNALOFCOMPUTERRESEARCHANDDEVELOPMENT 
 1999 年 第 36 卷 第 8 期 Vol.36 No.81999 
 
 
 
 ADA 程序 通信 死锁 的 动态 检测 方法 
 史晓华 　 高仲仪 　 邵 　 晖 
 摘 　 要 　 针对 ADA 并发 多任务 程序 的 特点 ， 文中 提出 一个 新 的 ADA 程序 动态 死锁 检测 方案 ， 并且 在 这个 理论 的 基础 上 实现 了 一个 动态 死锁 测试工具 DDTT ( dynamicdeadlocktestingtool ) . 此 工具 能够 正确 检测 ADA 多任务 程序 由于 通信 关系 不当 而 造成 的 死锁 . 文中 详细 介绍 了 动态 死锁 测试工具 DDTT 所 依赖 的 全部 概念 及 判定 规则 ， 以及 它 的 工作 原理 . 
 关键词 　 死锁 ， ADA 程序 ， 动态 检测 
 中图法 分类号 　 TP311 
 ADYNAMICDEADLOCKTESTINGMETHODOFACONCURRENTADAPROGRAM 
 SHIXiao - Hua , GAOZhong - Yi , andSHAOHui 
 ( SoftwareEngineeringInstitute ， BeijingUniversityofAeronauticsandAstronauticsBeijing100083 ) 
 Abstract 　 AccordingtothefeaturesofADAconcurrentprograms , anewtheoryisintroduced , whichcanbeusedtodetectmostdeadlocksinanADAprogram . AdeadlockdetectingtoolnamedDDTT ( dynamicdeadlocktestingtool ) relyingonthistheoryisdesigned . Thisdetectingtoolcanbeusedtodetectcommunicatingdeadlocksinamulti - taskADAprogram . ThetheoryanddetectingrulesusedbyDDTTaredescribedindetail . Finally , theworkingprincipleofDDTTisintroduced . 
 Keywords 　 deadlock , ADAprogram , dynamicdetecting 
 1 　 引 　 言 
 　 　 ADA 语言 是 美国国防部 领导 研制 的 三军 通用 语言 , 它 在 分布式系统 中 得到 了 广泛 的 应用 , 其 主要 原因 是 由于 ADA 提供 了 强有力 的 不 依赖于 平台 的 多任务 编程 环境 . 但 分布式 程序 有 几个 特殊 问题 需要 妥善解决 , 其中 之一 就是 如何 防止 死锁 . 任务 ( task ) 作为 并发 ADA 程序 中 最 基本 的 单元 ， 由于 其中 不 恰当 的 通信 语句 时序 可以 导致 程序 的 死锁 ， 这种 类型 的 死锁 是 可能 通过 分析 及 监控 检查 出来 的 . 
 　 　 静态 死锁 检测 是 发展 得 较 早 的 死锁 检测 方法 ， 其中 有 代表性 的 两种 方法 分别 为 有序 集 ［ 1 ］ 和 Petri 网 . 勿 庸 质疑 对 程序 做 静态 分析 可以 得到 一个 比较 全面 透彻 的 了解 ， 如果 借助 一个 好 的 分析模型 ， 是 可能 对 一个 被测 程序 的 各个方面 得到 比较 全面 的 理解 和 判定 的 . 但是 静态 的 分析 工具 有 两个 问题 是 很 难 处理 的 ： 一是 程序 中 的 任务 数组 、 入口 族 等 必须 在 实际 运行 中 决定 的 情况 ； 二是 静态 的 分析方法 为了 追求 全面 ， 最终 导致 NP 问题 、 组合 爆炸 . 同时 对 用户 来说 ， 静态 分析 得到 的 “ 可能 ” 死锁 的 报告 是 不 能够 满足 的 . 他们 更 关心 在 实际 运行 时 是否 会 产生 死锁 ， 实际 运行 时 的 “ 死机 ” 是否 为 死锁 等等 非常 具体 的 问题 . 因此 ， 国外 在 此 领域 已经 有所 研究 . 较 有 代表性 的 是 JindeCheng 提出 的 ADA 语言 中 死锁 的 完全 分类 方法 并且 给出 了 相应 的 解决 方法 ， 并 提出 了 一个 采用 动态 监控 方式 进行 实时 死锁 检测 的 方案 ［ 2 ］ ， 而 在 国内 尚未 见到 有 这样 的 研究成果 . 本文 所作 的 主要 工作 是 ： 给出 了 ADA 任务 通信 死锁 的 定义 ； 提出 了 描述 单元 通信 关系 的 UDG 图 的 形式化 表示 方法 ； 提出 并 证明 了 死锁 的 判定 定理 ； 以及 在 上述 理论 工作 的 基础 上 实现 了 一个 动态 检测 ADA 任务 通信 死锁 的 工具 原型 . 
 　 　 文中 将 首先 讨论 采用 动态 监控 手段 检测 ADA 程序 中 由于 任务 通信 语句 的 不 恰当 时序 而 导致 死锁 所 依赖 的 主要 理论 ， 然后 简单 介绍 在 此基础 上 我们 业已 实现 的 一个 动态 死锁 检测工具 DDTT ( dynamicdeadlocktestingtool ) . 
 2 　 动态 死锁 检测 的 理论 准备 
 2.1 　 任务 通信 死锁 的 定义 
 　 　 定义 1 . 通信 语句 
 　 　 我们 称 一个 任务 的 入口 接收 语句 或 针对 某一 任务 的 入口 调用 语句 为 ADA 语言 的 通信 语句 . 
 　 　 定义 2 . ADA 语言 的 任务 通信 死锁 
 　 　 一个 并发 ADA 程序 的 任务 通信 死锁 是 指 程序 中 一个 或 多个 任务 的 通信 语句 处于 一种 并非 死循环 导致 的 无限 等待 状态 ， 从而 导致 这些 任务 无法 执行 下去 ( 如 不 特别 注明 ， 文中 提及 的 “ 死锁 ” 即 为 “ ADA 语言 任务 通信 死锁 ” ) . 
 2.2 　 死锁 的 判定 方法 
 2.2 . 1 　 单元 通信 关系 的 UDG 图 表示 方法 . 
 　 　 首先 是 一些 重要 的 概念 准备 ［ 3 ］ ： 
 　 　 定义 3 . 可 执行 单元 可 分为 如下 4 类 ： 
 　 　 ( 1 ) Subprogram : 包括 ① procedure ， ② function ； 
 　 　 ( 2 ) Block : 包括 ① declare - block ， ② accept - block ； 
 　 　 ( 3 ) Task : 包括 ① taskbody ， ② theobjectofatasktype ； 
 　 　 ( 4 ) Package : 包括 ① packagespecification ， ② packagebody . 
 　 　 定义 4 . 活动 单元 
 　 　 我们 称 一个 可 执行 单元 为 活动 的 ， 当且 仅 当 满足 以下 两种 情况 中 的 一种 ： 
 　 　 ( 1 ) 对于 一个 拥有 withpackages 的 主 单元 而言 ， 程序 开始 执行 其 直接 或 间接 with 的 package 的 代码 ； 
 　 　 ( 2 ) 对于 其他 可 执行 单元 而言 ， 程序 开始 执行 属于 此 单元 的 首行 代码 ； 
 并且 这个 单元 的 运行 没有 终止 . 
 　 　 特别 地 ， 程序 在 不同 时刻 或 不同 位置 调用 同一个 Subprogram 或 声明 同一个 tasktype 的 不同 对象 或 执行 同 一段 taskbody 的 代码 ， 我们 定义 它们 针对 某一 特定 时刻 是 不同 的 活动 单元 . 针对 递归 程序 而言 ， 此点 尤为重要 . 
 　 　 定义 5 . 活动 单元 的 确立 阶段 ( elaboration ) 
 　 　 我们 称 一个 活动 单元 处于 确立 阶段 ， 当且 仅 当此 活动 单元 尚未 完成 其 声明 部分 代码 的 运行 . 
 　 　 定义 6 . 活动 单元 的 执行 阶段 
 　 　 我们 称 一个 活动 单元 处于 执行 阶段 ， 当且 仅 当此 活动 单元 不 处于 确立 阶段 . 
 　 　 定义 7 . 活动 单元 的 完成 状态 
 　 　 我们 称 一个 处于 执行 阶段 的 活动 单元 为 完成 状态 ， 当且 仅 当此 单元 执行 到 其 END 语句 之前 而 尚未 执行 它 的 结束 语句 . 
 　 　 定义 8 . 终止 单元 
 　 　 我们 称 一个 活动 单元 在 完成 其 END 语句 的 执行 之后 ， 此 单元 为 终止 的 . 
 　 　 定义 9 . 外延 单元 
 　 　 我们 称 一个 活动 单元 Unit1 为 另 一个 活动 单元 Unit2 的 外延 单元 ， 当且 仅 当 它们 满足 以下 3 种 关系 中 的 一种 ： 
 　 　 ( 1 ) Unit1 是 Unit2 通过 with 语句 直接 或 间接 引用 的 包 ， 并且 Unit2 为 这个 并发 ADA 程序 的 主 单元 ； 
 　 　 ( 2 ) Unit1 是 Unit2 调用 的 子程序 ； 
 　 　 ( 3 ) Unit1 是 Unit2 体中 直接 声明 的 属于 定义 3 中类 2 中 的 单元 . 
 　 　 定义 10 . 直接 激活 
 　 　 我们 称 一个 活动 的 Task 或 TaskType 的 对象 是 被 一个 属于 定义 3 类 1 ， 2 ， 3 中 的 活动 单元 直接 激活 的 ， 当且 仅 当 这个 任务 满足 以下 两种 关系 中 的 一种 ： 
 　 　 ( 1 ) 这个 task 或 tasktype 的 对象 是 在 这个 可 执行 单元 的 声明 部分 直接 说明 的 ； 
 　 　 ( 2 ) 这个 task 或 tasktype 的 对象 是 在 被 这个 可 执行 单元 直接 或 间接 引用 的 包中 （ 包括 包 的 体及 包 的 声明 ） 直接 说明 的 ， 并且 这个 可 执行 单元 是 这个 并发 ADA 程序 的 主 单元 . 
 　 　 定义 11 . 单元 标识码 
 　 　 在 一个 并发 ADA 程序 中 ， 每 一个 活动 单元 都 拥有 一个 唯一 的 标识码 直至 其 进入 终止 状态 ； 此码 作为 区分 不同 活动 单元 的 唯一 标识 . 
 　 　 定义 12 . 任务 标识码 
 　 　 在 一个 并发 ADA 程序 中 ， 每个 活动 单元 （ 包括 定义 3 中 所有 4 类 可 执行 单元 ） 都 拥有 一个 任务 标识码 . 对于 每个 活动 或 终止 的 task 或 tasktype 的 对象 而言 ， 此码 都 是 唯一 的 . 即 不同 的 task 或 tasktype 的 对象 或 同一 tasktype 的 不同 对象 都 拥有 一个 可以 唯一 区分 自己 的 任务 标识码 . 
 　 　 特别 地 ， 我们 定义 一个 不 具有 任务 的 顺序 流 程序 中 的 所有 活动 单元 都 拥有 一个 同样 的 任务 标识码 . 
 　 　 定义 13 . 我们 定义 两个 活动 单元 Unit1 ， Unit2 拥有 同样 的 任务 标识码 ， 当且 仅 当 这 两个 单元 满足 以下 两种 关系 中 的 一种 ： 
 　 　 ( 1 ) Unit1 为 Unit2 的 外延 单元 ， 或 反之 ； 
 　 　 ( 2 ) 存在 这样 一个 有序 集合 ： 
 ｛ P1 ， … ， Pm ｝ 　 　 m ＞ 0 ； 
 　 　 　 　 ① P1 为 Unit1 的 外延 单元 ； 
 ② Unit2 为 Pm 的 外延 单元 ； 
 ③ 对于 任何 存在 的 1 ＜ i ≤ m ， Pi 为 Pi - 1 的 外延 单元 ； 
 或 将 上述 的 Unit1 与 Unit2 变换位置 . 
 　 　 定义 14 . 父 单元 
 　 　 我们 称 直接 激活 一个 task 或 tasktype 的 对象 的 活动 单元 为此 任务 的 父 单元 . 由 定义 12 可知 ， 一个 任务 单元 的 父 单元 的 任务 标识码 不同于 此 任务 的 任务 标识码 ， 并且 也 不同于 非 它 本身 的 任何 其它 活动 或 终止 的 任务 单元 的 任务 标识码 . 
 　 　 定义 15 . 活动 单元 的 完成 等待 状态 
 　 　 我们 称 一个 活动 单元 处于 完成 等待 状态 ， 当且 仅 当 它 同时 满足 以下 两种 情况 ： 
 　 　 ( 1 ) 此 活动 单元 处于 完成 状态 ； 
 　 　 ( 2 ) 此 活动 单元 直接 激活 的 任务 中 ， 尚有 未 处于 终止 状态 的 单元 . 
 　 　 定义 16 . 单元 描述 图 ( unitdescriptiongraph ) 
 　 　 我们 定义 这样 一个 有向图 ， 它 针对 于 某 一 特定 时刻 t （ 对于 实时 嵌入式 系统 interleavedimplementation ， t 为 某 一 物理 时刻 ； 对于 分布式系统 distributedimplementation ， t 为 某 一虚 时刻 ） ， 某一 特定 的 被 测 并发 ADA 程序 P ： 用 符号 表示 为 UDG ( P , t ) ， 对应 一个 9 元组 的 有向图 ： 
 ( OA ( P , t ) ， OF ( P , t ) ， E ( P , t ) ， Aact ， Aext ， Acall ， Aacc ， D ， W ) 
 ( 1 ) OA ( P , t ) ＝ OAT ( P , t ) ∪ OAB ( P , t ) ∪ OAS ( P , t ) ∪ OAP ( P , t ) 
 其中 OAT ( P , t ) 表示 所有 在 时刻 t 的 属于 定义 3 类 3 中 的 活动 单元 ； 
 　 　 OAB ( P , t ) 表示 所有 在 时刻 t 的 属于 定义 3 类 2 中 的 活动 单元 ； 
 　 　 OAS ( P , t ) 表示 所有 在 时刻 t 的 属于 定义 3 类 1 中 的 活动 单元 ； 
 　 　 OAP ( P , t ) 表示 所有 在 时刻 t 的 属于 定义 3 类 4 中 的 活动 单元 ； 
 　 　 ( 2 ) OF ( P , t ) ＝ OFT ( P , t ) ∪ OFB ( P , t ) ∪ OFS ( P , t ) ∪ OFP ( P , t ) 
 其中 OFT ( P , t ) 表示 所有 在 时刻 t 之前 终止 的 属于 定义 3 类 3 中 的 单元 ； 
 　 　 OFB ( P , t ) 表示 所有 在 时刻 t 之前 终止 的 属于 定义 3 类 2 中 的 单元 ； 
 　 　 OFS ( P , t ) 表示 所有 在 时刻 t 之前 终止 的 属于 定义 3 类 1 中 的 单元 ； 
 　 　 OFP ( P , t ) 表示 所有 在 时刻 t 之前 终止 的 属于 定义 3 类 4 中 的 单元 ； 
 　 　 ( 3 ) E ( P , t ) 为 P 中 所有 在 时刻 t 的 活动 单元 及 时刻 t 之前 终止 的 任务 单元 的 入口 声明 的 集合 ； 
 　 　 ( 4 ) Aact ＝ OA ( P , t ) × OAT ( P , t ) 
 　 　 Aact 表示 OA ( P , t ) 与 OAT ( P , t ) 之间 的 这样 一种 二元关系 ： 
 　 　 对于 任意 的 V1 ∈ OA ( P , t ) ， V2 ∈ OAT ( P , t ) ， 当且 仅 当 V2 是 被 V1 直接 激活 的 ， ( V1 , V2 ) ∈ Aact ； 
 　 　 ( 5 ) Aext ＝ OA ( P , t ) × （ OAB ( P , t ) ∪ OAS ( P , t ) ∪ OAP ( P , t ) ） 
 　 　 Aext 表示 OA ( P , t ) 与 OAB ( P , t ) ∪ OAS ( P , t ) ∪ OAP ( P , t ) 之间 的 这样 一种 二元关系 ： 
 　 　 对于 任意 的 V1 ∈ OA ( P , t ) ， V2 ∈ OAB ( P , t ) ∪ OAS ( P , t ) ∪ OAP ( P , t ) ， 当且 仅 当 V2 是 V1 的 外延 单元 ， ( V1 , V2 ) ∈ Aext ； 
 　 　 ( 6 ) Acall ＝ （ OAT ( P , t ) ∪ OAB ( P , t ) ∪ OAS ( P , t ) ） × （ OAT ( P , t ) ∪ OFT ( P , t ) ） × E ( P , t ) 
 　 　 Acall 表示 OAT ( P , t ) ∪ OAB ( P , t ) ∪ OAS ( P , t ) 与 OAT ( P , t ) ∪ OFT ( P , t ) 与 E ( P , t ) 之间 的 这样 一种 三元 关系 ： 
 　 　 对于 任意 的 V1 ∈ OAT ( P , t ) ∪ OAB ( P , t ) ∪ OAS ( P , t ) ， V2 ∈ OAT ( P , t ) ∪ OFT ( P , t ) ， e ∈ E ( P , t ) ， 当且 仅 当 V1 无条件 调用 属于 V2 声明 的 入口 e ， ( V1 , V2 , e ) ∈ Acall ； 
 　 　 ( 7 ) Aacc ＝ （ OAT ( P , t ) ∪ OAB ( P , t ) ） × （ OAT ( P , t ) ∪ OAB ( P , t ) ） × E ( P , t ) 
 　 　 Aacc 表示 （ OAT ( P , t ) ∪ OAB ( P , t ) ） 与 （ OAT ( P , t ) ∪ OAB ( P , t ) ） 与 E ( P , t ) 之间 的 这样 一种 三元 关系 ： 
 　 　 对于 任意 的 V1 ∈ （ OAT ( P , t ) ∪ OAB ( P , t ) ） ， e ∈ E ( P , t ) ， 当且 仅 当 满足 以下 两个 条件 中 的 一种 ： 
 　 　 . V1 无条件 接收 等待 一个 入口 e ； 
 　 　 . V1 在 一个 选择 段 中 条件 接收 入口 e ， 并且 同时 满足 下列 4 个 条件 ： 
 　 　 　 　 ① e 已经 进入 V1 的 接收 等待 队列 ； 
 ② e 还 没有 进入 其 会合 阶段 的 执行 ； 
 ③ e 没有 被 一个 时间 限制 或 被 一个 else 语句 所 约束 或 被 一个 orterminate 语句 所 约束 ； 
 ④ 不 存在 a = ( V1 ， Vk ) ∈ Aext ； ( V1 ， V1 ， e ) ∈ Aacc . 
 　 　 ( 8 ) D ＝ OA ( P , t ) × OAT ( P , t ) 
 　 　 D 表示 OA ( P , t ) 与 OAT ( P , t ) 之间 的 这样 一种 二元关系 ： 
 　 　 对于 任意 的 V1 ∈ OA ( P , t ) ， V2 ∈ OAT ( P , t ) ， 当且 仅 当 下列 3 个 条件 同时 成立 ： 
 　 　 　 　 ① ( V1 , V2 ) ∈ Aact ； 
 ② V1 ， V2 都 处于 活动 单元 的 确立 阶段 ； 
 ③ 不 存在 这样 一个 V3 ∈ OAT ( P , t ) ， 使得 ( V2 , V3 ) ∈ D ； ( V1 , V2 ) ∈ D . 
 　 　 ( 9 ) W ＝ （ OAT ( P , t ) ∪ OAB ( P , t ) ∪ OAS ( P , t ) ） × OAT ( P , t ) 
 　 　 W 表示 OAT ( P , t ) ∪ OAB ( P , t ) ∪ OAS ( P , t ) 与 OAT ( P , t ) 之间 的 这样 一种 二元关系 ： 
 　 　 对于 任意 的 V1 ∈ OAT ( P , t ) ∪ OAB ( P , t ) ∪ OAS ( P , t ) ， V2 ∈ OAT ( P , t ) ， 当且 仅 当 下列 两个 条件 同时 成立 ： 
 　 　 　 　 ① V1 处于 完成 等待 状态 ； 
 ② ( V1 , V2 ) ∈ Aact ； ( V1 , V2 ) ∈ W . 
 2.2 . 2 　 死锁 的 判定 定理 
 　 　 定理 1 . 活动 单元 死锁 的 充分条件 ： 给定 一个 UDG ( P , t ) 中 ： 
 　 　 ( 1 ) 存在 a = （ V1 ， V2 ， e1 ） ∈ Acall ； 
 　 　 如果 V2 ∈ OFT ， 我们 称 V1 由于 呼叫 一个 已经 终止 的 单元 而 导致 死锁 . 
 　 　 ( 2 ) 存在 a = （ V1 ， V2 ， e1 ） ∈ Acall ； 
 　 　 如果 V2 ∈ OAT 并且 V2 处于 完成 状态 ， 我们 称 V1 由于 呼叫 一个 已经 完成 的 单元 而 导致 死锁 . 
 　 　 ( 3 ) 存在 a = （ V1 ， V2 ， e1 ) ∈ Acall ； 
 　 　 如果 V2 已经 处于 死锁 状态 ， 我们 称 V1 由于 呼叫 一个 已经 死锁 的 单元 而 导致 死锁 . 
 　 　 ( 4 ) 存在 a = （ V1 ， V2 ) ∈ Aext ； 
 　 　 如果 V2 已经 处于 死锁 状态 ， 我们 称 V1 为 死锁 的 . 
 　 　 ( 5 ) 存在 a = （ V1 ， V2 ) ∈ D ； 
 　 　 如果 V2 已经 处于 死锁 状态 ， 我们 称 V1 为 死锁 的 . 
 　 　 ( 6 ) 存在 a = （ V1 ， V2 ) ∈ W ； 
 　 　 如果 V2 已经 处于 死锁 状态 ， 我们 称 V1 为 死锁 的 . 
 　 　 ( 7 ) 存在 一个 有 向 环 ： a1 ， … ， an ， n ≥ 1 
 　 　 其中 　 　 ai ∈ Acall ， 或 
 　 　 　 　 　 　 ai ∈ Aext ， 或 
 　 　 　 　 　 　 ai ∈ D ， 或 
 　 　 　 　 　 　 ai ∈ W 　 （ 1 ≤ i ≤ n ) ， 
 　 　 并且 当 我们 把 ai = （ Vi ， Vi + 1 ， ei ) ∈ Acall 写成 的 形式 时 ， 这个 有 向 环 可以 表示 为 
 （ V1 ， V2 ) ， … ， （ Vn ， V1 ) ； 
 　 　 我们 认为 所有 这个 环上 的 节点 Vi ∈ OA （ 1 ≤ i ≤ n ) 都 是 死锁 的 . 
 　 　 证明 . 根据 ADA 语义 ， ( 1 ) ～ ( 6 ) 是 成立 的 . 下面 我们 仅 证明 ( 7 ) . 
 　 　 首先 根据 定义 4 、 9 、 10 、 16 可知 ： ( 1 ) 中 定义 的 有 向 环中 ， 存在 并且 至少 存在 一个 ai ∈ Acall . 
 　 　 下面 我们 根据 数学 归纳法 来 证明 这一 结论 . 
 　 　 由 死锁 的 定义 ( 定义 1 ) ， 不防设 a1 = （ Vi ， Vi + 1 ， ei ) ∈ Acall ： 
 　 　 ① 当 这个 环 中 只有 一个 边 ， 即 n = 1 时 ： 
 a1 = （ V1 ， V1 ， ei ) . 
 　 　 我们 知道 一个 呼叫 了 自身 入口 的 调用 永远 不能 产生 会合 ， 由 定义 2 可知 V1 为 死锁 的 . 即 对于 所有 的 Vi （ 1 ≤ i ≤ n ) ， Vi 为 死锁 的 . 
 　 　 ② 假设 n = k 时 ， 对于 拥有 k 条边 的 有 向 环中 所有 的 Vi （ 1 ≤ i ≤ n ) ， Vi 为 死锁 的 . 当 我们 把 它 写成 ( 1 ) 中 描述 的 简写 形式 时有 
 （ V1 ， V2 ) ， … ， （ Vk ， V1 ) ； 
 　 　 ③ 当 n = k + 1 时 ， 由题 设知 ak + 1 ∈ Acall 或 Aext 或 D 或 W . 我们 首先 讨论 当 ak + 1 = （ Vk + 1 ， V1 ， ek + 1 ) ∈ Acall 时 的 情况 ： 
 　 　 将 a1 ～ ak + 1 写成 ( 1 ) 中 描述 的 简写 形式 ： 
 （ V1 ， V2 ) ， … ， （ Vk ， Vk + 1 ) ， （ Vk + 1 ， V1 ) ； 
 　 　 由 定义 16 可知 ， Vk 能否 继续执行 将 取决于 Vk + 1 的 运行 状态 ， 而 Vk + 1 能否 继续执行 — — 即 能否 同 V1 产生 一个 会合 , 将 取决于 V1 的 运行 状态 ， 也 就是 Vk 通过 Vk + 1 将 依赖于 V1 的 运行 状态 . 这样 我们 看到 在 V1 - V2 … - Vk - V1 之间 产生 了 一个 相互依赖 的 环 ， 而 根据 ( 2 ) 中 的 假设 ， 这样 的 环上 每 一个 节点 都 是 死锁 的 . 由 ( 3 ) 可知 ， （ Vk + 1 ， V1 ， ek + 1 ) 中 由于 Vk + 1 呼叫 了 一个 已经 死锁 的 节点 V1 ， 因此 Vk + 1 也 是 死锁 的 . 即 对于 所有 的 Vi （ 1 ≤ i ≤ k + 1 ) 都 是 死锁 的 . 
 　 　 当 ak + 1 ∈ Aext 或 D 或 W 时 ， 由 定义 16 及 上述 证明 同理可知 这个 有 向 环上 的 所有 结点 都 为 死锁 的 . 
 　 　 定理 2 . 死锁 的 判定 定理 
 　 　 给定 一个 UDG ( P , t ) ， 对于 任意 的 Vj 属于 OA ， 当 它 满足 以下 两种 条件 之一 ， 我们 称 这个 程序 中 的 所有 活动 单元 为 死锁 的 ： 
 　 　 ( 1 ) 根据 定理 1 ， 可 判定 Vj 为 死锁 的 ； 
 　 　 ( 2 ) 存在 这样 的 有 向 链 ： 
 　 　 a1 ， … ， an ， 　 n ≥ 0 ； 
 　 　 当 n ＞ 0 时 ， 其中 
 　 　 　 　 　 　 ai ∈ Acall ， 或 
 　 　 　 　 　 　 ai ∈ Aext ， 或 
 　 　 　 　 　 　 ai ∈ D ， 或 
 　 　 　 　 　 　 ai ∈ W 　 　 （ 1 ≤ i ＜ n ) ； 
 　 　 an = （ Vn ， Vn ， en ) ∈ Aacc ； 
 　 　 a1 是从 节点 Vj 引出 的 边 . 
 　 　 这个 有 向 链 满足 这样 的 特性 ： 
 　 　 如果 存在 一个 最靠近 an 的 am = （ Vm ， Vm + 1 ， em ) ∈ Acall ， 并且 Vm + 1 的 任务 标识码 与 Vn 的 任务 标识码 相同 ， 那么 不 存在 （ Vn ， Vn ， ek ) ∈ Aacc ， 使得 ek = em . 
 　 　 证明 . 即证 如果 一个 UDG 图中 所有 活动 单元 满足 上述 两个 条件 之一 ， 这个 程序 中 的 所有 活动 单元 为 死锁 的 . 
 　 　 如果 一个 活动 单元 Vj 满足条件 1 ， 显见 它 是 死锁 的 ； 
 　 　 如果 这个 活动 单元 满足条件 2 ， 即 是 说 Vj 能否 继续执行 取决于 Vn 是否 可以 产生 一个 会合 . 而 由 条件 ( 2 ) 中 这个 有 向 链 的 特性 可知 ， 根本 不会 存在 这样 的 一个 活动 单元 Vl ， 使得 Vl 呼叫 Vn 正在 等待 的 入口 并且 产生 一个 会合 . 也就是说 Vj 不 可能 继续执行 下去 ， 它 为 死锁 的 . 
 3 　 动态 死锁 检测工具 的 实现 
 　 　 动态 死锁 检测工具 DDTT 由 两 部分 组成 ， 其一 是 预 处理器 ， 另 一个 是 监控器 . 
 3.1 　 预 处理器 
 　 　 预 处理器 由 静态 分析器 、 源程序 转换器 及 一个 任务 消息 处理 包 组成 . 如图 1 所示 . 
 
 
 图 　 1 
 　 　 静态 分析器 作为 ADA 程序 理解 的 一个 基础性 的 工具 ， 它 对 文法 上 符合 ADA83 文本 的 ADA 源代码 进行 分析 . 它 不 需要 运行 源程序 ， 而是 将 ADA 源程序 作为 系统 的 输入 数据 ， 自动 地 产生 被测 程序 的 静态 属性 表格 ， 为 动态 测试 以及 其它 测试 奠定 数据 基础 . 
 　 　 源程序 转换器 又称 源码 处理器 ， 是 整个 预 处理器 中 技术 上 的 关键 部分 . 顾名思义 ， 这 一部分 的 功能 是 将 一个 被测 程序 P 转化 为 我们 所 需要 的 程序 P ′ ， 而 转化 过程 中 所 依赖 的 程序 信息 得 自于 静态 分析器 . 我们 总 的 原则 是 在 程序 中 插装 适当 的 语句 来 获知 定义 3 ～ 15 中 的 各种 单元 的 运行 状态 及 它们 之间 的 各种 关系 . 
 　 　 任务 消息 处理 包 单独 编译 后 留在 共享 库中 . 由于 它 独立 于 任何 不同 的 被 测 文件 ， 因此 被 修改 后 的 被 测 文件 将 引用 这 一个 程序包 . 
 3.2 　 监控器 
 　 　 监控器 与 被 测 程序 将 采用 进程 通信 的 手段 来 达到 任务 消息 共享 . 我们 在 系统 中辟 出 一块 专用 文件 缓冲区 用来 进行 被测 程序 与 监控器 之间 的 通信 . 
 　 　 被测 程序 的 任务 消息 处理 是 在 一个 独立 的 任务 中 进行 ， 我们 可以 把 这个 任务 看做 是 一个 缓冲器 ， 被测 程序 只 需 在 插装 位置 上 调用函数 向 内存 中 的 消息 队列 写入 有关 信息 即可 ； 同时 这个 任务 从 内存 中 取出 消息 后 放入 文件 缓冲区 . 监控器 最终 从文件 缓冲区 中 取得 相应 的 消息 ， 根据 前述 定义 及 死锁 的 判定 定理 加以 处理 . 
 4 　 结束语 
 　 　 文中 提出 了 在 一个 并发 ADA 程序 起始 运行 后 的 任意 时刻 t ， 根据 不同 任务 单元 的 状态 来 判断 此 程序 是否 处于 由于 通信 设计 不当 而 导致 的 死锁 状态 的 解决方案 . 根据 此 方案 并 在 本 研究所 “ 七五 ” 、 “ 八五 ” 以来 业已 完成 的 ADA 软件测试 工具 的 基础 上 ， 我们 实现 了 一个 具有 较 好 实用性 、 对 此类 死锁 具有 比较 完全 覆盖面 的 ADA 程序 动态 死锁 检测工具 . 完全 解决 死锁 问题 是 还有 很 漫长 的 路 要 走 的 ， 但是 我们 本着 了解 一部分 、 解决 一部分 的 方针 ， 希望 能够 将 问题 缩小 ， 在 这 一 领域 有所前进 . 
 作者简介 ： 史晓华 ， 男 ， 1973 年 3 月生 ， 博士 研究生 ， 主要 研究 领域 为 软件工程 和 软件测试 技术 . 高仲仪 ， 男 ， 1935 年 1 月生 ， 教授 ， 主要 研究 领域 为 形式语言 与 自动机 理论 、 软件 质量 与 可靠性 、 软件 及 软件工程 环境 、 过程 工程 . 邵晖 ， 男 ， 1969 年 5 月生 ， 硕士 研究生 ， 主要 研究 领域 为 嵌入式 系统 的 开发 与 测试 、 软件工程 及其 环境 . 
 作者 单位 ： 史晓华 　 高仲仪 　 邵 　 晖 　 北京航空航天大学 软件工程 研究所 　 北京 　 100083 
 参考文献 
 1 　 周伯生 . ADA 程序 的 死锁 检测 原理 . 见 : 周伯生 主编 . 计算机软件 开发方法 、 工具 和 环境 . 西安 : 西北工业大学 出版社 ， 1985 , 117 ～ 129 
 ( ZhouBosheng . AdeadlockdetectingtheoryofADAprogram . In : ZhouBoshenged . ComputerSoftwareDevelopingMethods , Tools , andEnvironment ( inChinese ) . Xi ' an : NorthwestIndustryUniversityPress , 1985 , 117 ～ 129 ) 
 2 　 ChengJingde . Asurveyoftaskingdeadlockdetectionmethods . ACMAdaLetters , 1991 , 11 ( 1 ) : 82 ～ 91 
 3 　 ANSI / MIL - STD - 1815A - 1983ReferenceManualfortheAdaProgrammingLanguage . Washington : AdaJointProgramOffice , 1983 
 收到 日期 ： 1997 - 11 - 19 
 修改 日期 ： 1999 - 03 - 08 
