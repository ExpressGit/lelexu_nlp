计算机 研究 与 发展 
 JOURNALOFCOMPUTERRESEARCHANDDEVELOPMENT 
 1999 年 　 第 36 卷 　 第 11 期 　 Vol.36 　 No.11 　 1999 
 
 
 
 用 遗传算法 构造 二元 决策树 
 吴 　 菲 　 黄 梯云 
 摘 　 要 ： 决策树 的 方法 是 一种 优化 的 过程 ， 遗传算法 是 模拟 自然 进化 的 通用 全局 搜索算法 ， 文中 将 遗传算法 应用 到 构造 优化 决策树 ， 提出 了 采用 遗传算法 求解 二元 决策树 的 非叶 结点 的 权值 矢量 ， 进而 构造 二元 决策树 的 方法 . 并 讨论 了 遗传算法 的 评价 函数 构造 和 编码方法 ， 重点 说明 了 如何 对 遗传算法 进行 改进 ， 提高 算法 效率 ， 然后 分析 了 影响 二元 决策树 错误 分类 率 的 因素 ， 并用 实例 验证 该 方法 构造 的 二元 决策树 对 样本 分类 具有 很 高 的 辨识 率 . 
 关键词 ： 遗传算法 ， 二元 决策树 ， 权值 矢量 
 中图法 分类号 ： TP301 ； TP18 
 CONSTRUCTINGBINARYDECISIONTREESBY 
 USINGGENETICALGORITHM 
 WUFeiandHUANGTi - Yun 
 ( ManagementSchoolofHarbinInstituteofTechnology , Harbin150001 ) 
 Abstract 　 Decisiontreeisanoptimizationmethod . Bysimulatingthenatureevolution , geneticalgorithmbecomesakindofgeneral - purposeglobalsearchalgorithm . Anapproachtoconstructandoptimizedecisiontreebasedongeneticalgorithmisdiscussedinthepaperhere . Ageneticalgorithmisemployedateachnonterminalnodeofthebinarytreetosearchforweightvector . Toachievehighperformance , itsfitnessfunctionandencodingmethodarediscussedindetail , andinparticular , muchemphasisisputonitsoperatorevolution . Theeffectsofthemisclassificationrateofthebinarytreearediscussedandtheexperimentresultsshowthatthebinarydecisiontreeconstructedbasedongeneticalgorithmcanclassifysample - setaccurately . 
 Keywords 　 geneticalgorithm , binarydecisiontree , eightvector 
 1 　 引 　 言 
 　 　 遗传算法 是 一种 基于 生物学 进化 原理 的 搜索算法 ［ 1 ］ ， 它 模拟 达尔文 的 遗传 选择 和 自然 淘汰 的 计算 模型 ， 通过 在 求解 过程 中使 群体 不断 优化 ， 进而 找到 最优 解或准 最优 解 . 作为 一种 有效 的 全局 并行 优化 搜索 工具 ， 遗传算法 具有 简单 、 通用 、 鲁棒性 强 和 适于 并行处理 的 特点 ， 因而 在 工农业 、 经济 政治 、 科学 研 繶 等 方面 取得 了 广泛 的 应用 . 
 　 　 分类 系统 是 遗传算法 研 繶 的 一个 分支 ， 决策树 是 一种 结构 简单 、 搜索 效率高 的 分类器 ［ 2 ］ . 目前 出现 了 采用 遗传算法 对 决策树 结构 运算 ， 直接 构造 决策树 的 方法 ［ 3 ］ ， 但 没有 涉及 到 对 树 结点 的 决策函数 学习 . 文中 提出 采用 遗传算法 训练 树 结点 的 线性 决策函数 ， 进而 构造 二元 决策树 的 方法 . 
 2 　 基于 二元 决策树 的 遗传算法 设计 
 　 　 二元 决策树 包含 终结 点 （ 叶子 结点 ） 和 非 终结 点 ， 其中 终结 点 表示 类 属性 ， 非 终结 点 包括 决策函数 和 其 左右 子树 . 在 决策树 的 非 终结 点 进行 属性 值 的 比较 并 根据 属性 值 的 结果 判断 从 该 结点 向下 的 分支 ， 到达 的 终结 点 相对 应 的 类 则 是 输入 值 的 属性 ［ 4 ］ . 
 　 　 遗传算法 在 具体 问题 求解 过程 中 ， 要 确定 目标 的 评价 函数 和 变量 的 编码 机制 ， 以及 遗传算法 的 基本操作 ： 选择 、 交叉 和 变异 的 实现 方法 . 文中 重点 讨论 二元 决策树 的 评价 函数 、 编码 机制 及 交叉 、 变异 操作 的 改进 . 
 2.1 　 遗传算法 的 评价 函数 构造 
 　 　 评价 函数 是 遗传算法 与 具体 应用 问题 的 唯一 接口 ， 是 种群 中 个体 优劣 的 一种 量化 反映 ， 它 的 构造 直接 影响 问题 求解 的 效率 . 
 　 　 二元 决策树 的 错误 分类 率 是 评价 决策树 的 重要 标准 . 设 xt = { x1 , x2 , … , xNt } 为 到达 决策树 中 结点 t 的 训练样本 集 ， 设 xt = x1t ∪ x2t … xct , c 代表 类 的 数目 ， xit 代表 xt 中 属于 类 ω i 的 所有 样本 . 
 　 　 定义 1 . 定义 xt 的 错误率 为 其中 “ # ” 代表 样本 集 样本数 目的 大小 . 
 　 　 当 xt 仅 包含 来自 同 一类 的 样本 时 ， i ( xt ) = 0 . 设 结点 t 的 权值 矢量 为 w ， 其 将 xt 分为 左子 树 xtL ( w ) 和 右子 树 xtR ( w ) 两 部分 : 
 xtL ( w ) = { x | x ∈ xt ， 并且 wTx < 0 } ； 
 xtR ( w ) = { x | x ∈ xt ， 并且 wTx > 0 } . 
 　 　 我们 取 分割 后 的 错误率 i ′ ( xt , w ) 为 结点 xtL ( w ) 和 xtR ( w ) 错误率 的 加权 平均值 . 
 　 　 定义 2 . 样本 分割 后 的 错误率 . 
 i ′ ( xt , w ) = p ( xtL ( w ) | xt ) i ( xtL ( w ) ) + p ( xtR ( w ) | xt ) i ( xtR ( w ) ) ， 
 其中 ， 
 
 　 　 错误率 的 减少 量 Δ i ( xt , w ) = i ( xt ) - i ′ ( xt , w ) ， 它 表示 结点 t 的 样本 分割 前后 的 错误率 减少 量 ， 我们 选择 Δ i ( xt , w ) 为 评价 函数 ， 用以 选择 最好 的 决策函数 ， 使 错误率 的 减少 量 最大 ， 即 ： f ( y ) = Δ ixt , w ) . 
 2.2 　 遗传 算子 的 改进 
 2.2 . 1 　 交叉 算子 的 改进 
 　 　 交叉 是 指 把 两个 父代 个体 的 部分 结构 加以 替换 重组 而 生成 新 个体 的 操作 ， 是 GA 获取 新 优良 个体 的 最 重要 手段 . 交叉 操作 是 有照 一定 的 概率 Pc （ 即 交叉 概率 ） 在 配对 库中 随机 地 选取 两个 个体 进行 的 . 交叉 的 位置 也 是 随机 确定 的 . 交叉 概率 Pc 的 值 一般 取得 很大 ， 在 0.6 ～ 0.9 之间 . 
 　 　 最 简单 的 交叉 算子 是 单点 交叉 ， 但 由于 文中 所用 的 参数 的 位串 较长 ， 仅 采用 单点 交叉 ， 位串 的 结构 改变 很小 ， 不利于 新 信息 的 引入 ， 导致 搜索 效率 降低 . 为此 引入 了 两点 交叉 ， 即 在 染色体 中 随机 选取 两点 ， 然后 交换 两点 中 的 一段 基因 链 ， 一般来说 其 优于 单点 交叉 . 这种 改进 使得 交叉 操作 有效 地 作用 于 每个 参数 的 位串 上 ， 充分发挥 交叉 操作 的 威力 ， 同时 避免 了 参数 位串 破坏 过大 、 或 参数 位串 改变 甚小 的 不合理 情况 的 出现 . 实验 表明 ， 改进 后 的 交叉 算子 使 搜索 效率 得到 了 明显提高 . 
 2.2 . 2 　 变异 算子 的 改进 
 　 　 变异 是 按 一定 的 变异 概率 Pm 将位 串 的 某 一位 或 某 几位 的 1 变为 0 或 0 变为 1 . 变异 操作 即 保持 了 遗传算法 的 有效性 ， 又 是 防止 算法 早熟 的 措施 . 
 　 　 实验 表明 ， 遗传算法 能 较 快 地 搜索 到 局部 最优 解 ， 但 从 局部 最优 解 搜索 到 全局 最优 解则 需 花费 较长时间 . 为了 提高 搜索 效率 ， 提高 解 的 精度 ， 当 遗传算法 搜索 到 局部 最优 解时 ， 我们 有意 地 控制 使 参数 位串 的 末 几位 ， 即 最 不 重要 的 几位 发生 变异 ［ 5 ］ ， 这 相当于 给 参数 的 值 增加 或 减少 了 一个 小 的 步长 ， 从而 有 可能 以较 小 的 代价 找到 参数 的 最优 解 . 
 　 　 设 种群 的 个数 为 n ， 文中 对 变异 操作 的 对象 分为 两大类 ： 一类 是 适应 值较 高 的 m 个 个体 ， 对 这 m 个 个体 变异 时 ， 采用 如上所述 的 动态控制 变异 位置 的 方法 ， 而 对 另外 n - m 个 个体 变异 时 ， 仍然 采用 随机 选取 变异 位置 的 方法 . 这样 对于 适应 值高 的 个体 ， 采用 动态控制 变异 位置 的 方法 保持 了 算法 的 搜索 最优 解 能力 ， 而 对于 适应 值低 的 个体 ， 采用 随机 选取 变异 位置 的 方法 保证 了 算法 的 全局 搜索 能力 ， 保证 了 算法 的 有效性 . 动态控制 变异 位置 的 方法 实现 如下 ： 
 　 　 设 g 代表 进化 过程 中 的 繁衍 代数 ， g * 表示 最优 解 第一次 产生 时 的 繁衍 代数 , 迭代 次数 G ， bitLength 为 二进制 表示 的 个体 的 编码 长度 . 
 bit ＝ int ( ( ( g - g * ) / G ) × bitLength / 2 ) + 1 ; 
 bit1 ＝ int ( rand ( ) × ( bit - 1 ) + 1 ) . 
 　 　 当 g - g * 逐渐 增大 时 ， bit 从 bitLength / 2 变化 到 1 ， 变异 位置 bit1 的 取值 在 ［ bit ， 1 ］ 之间 . 
 2.2 . 3 　 动态 调整 交叉 概率 、 变异 概率 
 　 　 在 简单 遗传算法 中 ， 由于 Pc 和 Pm 取为 恒定 值 ， 因此 用于 复杂 的 多 变量 优化 问题 时 ， 效率 不高 ， 并且 存在 “ 早熟 ” 的 可能性 . 为了 提高效率 和 快速 获得 最优 解 ， 文中 根据 个体 的 适应度 值 动态 地 改变 Pc 和 Pm . 当 群体 有 陷入 局部 最优 解 的 趋势 时 ， 就 相应 地 提高 Pc 和 Pm ， 当 群体 在 解 空间 发散 时 ， 就 降低 Pc 和 Pm . 并且 ， 对于 适应 值高 的 个体 ， 对应 于 较 低 的 Pc 和 Pm ， 使 该解 得以 保护 进入 下一代 ； 而 对于 适应 值较 低 的 个体 ， 对应 于 较 高 的 Pc 和 Pm ， 使 该解 被 淘汰 掉 . 这样 即 保持 了 群体 的 多样性 ， 又 保证 了 遗传算法 的 收敛性 ， 有效 地 提高 了 遗传算法 的 优化 能力 . 
 　 　 动态 调整 交叉 概率 Pc 的 公式 为 
 
 其中 ， fmax 为 当前 种群 最大 的 适应度 值 ， favg 为 群体 的 平均 适应度 值 ， f ′ 为 待 交叉 的 两个 个体 中 较大 的 适应度 值 ， k1 ， k2 为 ［ 0 ， 1 ］ 之间 的 数 . 
 　 　 动态 调整 变异 概率 Pm 的 公式 相同 . 
 2.3 　 遗传算法 的 编码方法 
 　 　 编码方法 是 遗传算法 的 关键问题 ， 关系 到 能否 对 所 处理 的 问题 进行 合理 且 有效 的 描述 . 遗传算法 的 编码方法 主要 有 两种 ： 一种 是 二进制 编码 ， 另 一种 是 浮点数 编码 . 二进制 编码 是 遗传算法 中 常见 的 编码 技术 ， 它 的 优点 是 ： 容易 产生 和 操作 、 理论 上 容易 处理 、 几乎 任何 问题 都 可以 用 二进制 编码 ， 但是 二进制 编码 也 存在 一些 缺点 ： 首先 是 表示 精度 与 算法 效率 之间 的 矛盾 ； 其次 ， 二进制 编码 的 遗传算法 在 操作过程 中 ， 需要 不断 地 对 码串 进行 译码 ， 增加 了 算法 的 计算 量 ， 降低 了 算法 的 效率 . 浮点数 编码 的 表示 精度 依赖于 计算机 ， 只 由 计算机 字长 决定 ， 不 受 其他 条件 限制 ， 因而 具有 非常 高 的 表示 精度 . 此外 ， 浮点 表示 能够 表示 非常 大 的 区域 ， 并且 在 算法 操作过程 中 不 需要 进行 数制 转换 ， 提高 了 算法 的 效率 . 但是 ， 浮点 编码 也 存在 搜索 能力差 、 基因 操作 不 灵活 等 缺点 . 
 　 　 二进制 编码 和 十进制 编码 存在 各自 的 利弊 . 文中 采用 的 是 二进制 编码 的 方法 ， 是因为 二进制 编码 的 基因 操作 灵活 ， 并且 对 权值 矢量 w = ( w1 , w2 , … wn ) 中 的 每个 系数 wi ， i = ( 1 , 2 , … n ) , 对应 一个 20 位长 的 二进制 串 Ai ， 这样 wi 的 表示 精度 达到 10 - 6 ， 可以 满足 计算 的 需要 . 将 Ai 联结 在 一起 则 形成 对应 w 的 二进制 串 A , A = A1A2 … An . 设 T 代表 从权 矢量 w 到 对应 的 二进制 串 的 A 操作 ， 则 A = T ( w ) , w = T － 1 ( A ) . 
 3 　 权值 矢量 的 求解 
 　 　 遗传算法 求解 二元 决策树 结点 的 权值 矢量 有 两个 前提 ： 
 　 　 （ 1 ） 产生 一个 初始 种群 Ю 初始 种群 一般 为 随机 产生 ， 但 这样 容易 造成 基因 缺损 . 为了 使 产生 的 初始 种群 均匀 地 分布 在 解 空间 中 ， 文中 初始 解 的 产生 规定 如下 ： 
 　 　 假设 x1 和 x2 为 结点 t 中 两个 来自 不同 类 的 样本 ， xi = ( xi1 , xi2 , … xin , 1 ) T ， i = 1 , 2 ， 权值 矢量 w = ( x21 - 并 对 w 进行 线性 标准化 操作 ， 使 权值 矢量 的 每个 系数 wi 的 值 在 0 与 1 之间 ， 这样 算法 能够 更快 地 找到 优良 群体 所在 的 区域 ， 加快 迭代 收敛 速度 ， 有利于 提高 算法 的 效率 . 
 　 　 （ 2 ） 终止 条件 的 判定 . 文中 规定 为 产生 一定 的 后代 后 ， 若 其 权值 矢量 的 最优 解不 发生变化 ， 则 停止 . 
 　 　 遗传算法 求解 最优 权值 矢量 的 算法 如下 ： 
 　 　 步骤 1 . 建立 一个 初始 种群 p = { A1 , A2 , … An } , A * 为 当前 种群 中 的 最优 解 ， f * = f ( A * ) ， g * = g = 0 ， g 代表 进化 过程 中 的 繁衍 代数 ， g * 表示 最优 解 第一次 产生 时 的 繁衍 代数 ， n 代表 到达 当前 结点 的 样本 总数 . 
 　 　 步骤 2 . 对 当前 种群 p 中 的 每 一个 体 计算 适应度 值 ， f ( A ) = Δ i ( p , T － 1 ( A ) ) . 
 　 　 步骤 3 . 初始化 解 交配 池 M 和 后代 O ： 
 　 　 　 M ＝ ? 
 　 　 　 O ＝ ? 
 　 　 　 g = g + 1 
 　 　 步骤 4 . 复制 
 　 　 　 fori = 1tondo 
 　 　 　 从 当前 种群 p 中用 赌盘 选择 的 方法 选择 一个 个体 A ， 
 　 　 　 M = M ∪ A . 
 　 　 步骤 5 . 交叉 
 　 　 　 fori = 1ton / 2do 
 　 　 　 随机 地 从 交配 池 M 中 选择 个体 A ′ 和 A ″ ， 根据 个体 的 适应 值 ， 计算 动态 交叉 概率 Pc ， 并 按照 交叉 概率 Pc 进行 交叉 ， 
 　 　 　 M = M - { A ′ , A ″ } 
 　 　 　 O = O ∪ { A ′ , A ″ 按照 概率 Pc 交叉 的 后代 } . 
 　 　 步骤 6 . 变异 
 　 　 　 设 O = { Ao1 , Ao2 , … Aon } ， m 为 小于 n 的 某 一 整数 ， 
 　 　 　 在 当前 种群 p 中 选择 m 个 适应 值 最高 的 个体 ， 控制 个体 的 末 几位 进行 变异 ； 
 　 　 　 对 其他 n - m 个 个体 Aoi ， 根据 个体 的 适应 值 ， 计算 动态 变异 概率 Pm ， 并 对 Aoi 中 的 每 一位 按 概率 Pm 变异 . 
 　 　 步骤 7 . 替换 
 　 　 　 假设 Apb 和 Aow 分别 是 上 一代 种群 p 中 的 最优 解和新 产生 的 子代 O 中 的 最差 解 ： 
 　 　 　 P = ( O - { Aow } ) ∪ { Apb } . 
 　 　 步骤 8 . 假设 Ab 为 新一代 p 中 的 最优 解 
 　 　 　 if 　 f ( Ab ) > f * 
 　 　 　 thenAb * = f ( Ab ) , g * = 转 步骤 2 ； 
 　 　 　 elseifg - g * < G , G 为 预先 给定 的 一 控制 常量 ， 
 　 　 　 　 then 　 转 步骤 2 ； 
 　 　 　 　 else 　 返回 最优 解 A * b . 
 4 　 二元 决策树 构造 
 　 　 文中 采用 自上而下 的 方法 构造 二元 决策树 ， 即 从 二元 决策树 的 根 结点 开始 用 遗传算法 求解 结点 的 权值 矢量 ， 使得 结点 的 决策 燽 数 分割 样本 后 的 错误率 减少 量 达到 最大 ， 求解 出 的 权值 矢量 将 样本 分割 为 两个 子集 ， 并 建立 此 结点 的 二 个子 结点 ， 重复 此 分割 过程 直到 结点 满足 终止 条件 ， 则 定义 此 结点 为 终结 点 . 为了 叙述 方便 ， 定义 如下 术语 . 
 　 　 定义 3 . N0 为 预定 义 结点 所 必须 的 最少 样本数 . 
 　 　 定义 4 . I1 为 预定 义 结点 的 最小 错误率 值 . 
 　 　 定义 5 . I2 为 预定 义 结点 分割 后 的 错误率 减少 量 最小值 . 
 　 　 定义 6 . 终止 条件 为 i ( xt ) 小于 I1 、 或 # xt 小于 N0 或 Δ i ( xt , ) 小于 I2 . 
 　 　 满足 终止 条件 的 结点 为 终结 点 ， 其类 属性 ω i ， 按 以下 公式 计算 ： 
 
 　 　 二元 决策树 的 结点 数据结构 用 C++ 表示 如下 ： 
 　 　 　 classTreeNode : publicCObject { 
 　 　 　 　 public ： 
 　 　 　 　 　 　 classTreeNode 　 * m _ left ; / / 左 结点 指针 
 　 　 　 　 　 　 classTreeNode 　 * m _ right ; / / 右 结点 指针 
 　 　 　 　 　 　 CVectorm _ weight ; / / 权值 矢量 
 　 　 　 　 　 　 CObArraym _ sampleSet ; / / 结点 所 含 样本 数目 
 　 　 　 　 　 　 intm _ classType ; / / 类 属性 ω i 
 　 　 　 　 } 
 　 　 构造 二元 决策树 的 算法 如下 ： 
 　 　 步骤 1 . 打开 样本 库 ； 
 　 　 步骤 2 . 对 样本 进行 线性 标准化 ； 
 　 　 步骤 3 . 生成 根 结点 ； 
 　 　 步骤 4 . 递归 建立 二元 决策树 ； 
 　 　 ① 若 # xt < N0 ， 则 结点 t 为叶 结点 ， 返回 . 
 　 　 ② 若 i ( xt ) < I1 ， 则 结点 t 为叶 结点 ， 返回 . 
 　 　 ③ 用 遗传算法 求解 结点 t 的 权值 矢量 w . 
 　 　 ④ 按权值 矢量 w 分割 xt 为 xtL 和 xtR ， 
 　 　 　 　 xtL ( w ) = { x | x ∈ xt , 并且 wTx < 0 } 
 　 　 　 　 xtR ( w ) = { x | x ∈ xt , 并且 wTx > 0 } 
 　 　 计算 分割 后 的 Δ i ( xt , w ) 值 . 
 　 　 ⑤ 若 Δ i ( xt , w ) 小于 I2 ， 定义 结点 t 为叶 结点 ， 置 结点 的 左右 子树为 空 ， 否则 生成 结点 t 的 左子 结点 和 右子 结点 ， 其所含 样本 集 分别 为 xtL 和 xtR . 
 　 　 　 　 对 结点 t 的 左子 结点 递归 调用 建立 二元 决策树 ； 
 　 　 　 　 对 结点 t 的 右子 结点 递归 调用 建立 二元 决策树 . 
 步骤 5 . 对 每个 叶 结点 ， 计算 它 的 类 属性 . 返回 决策树 T . 
 5 　 实验 结果 
 　 　 现以 股票 评估 为例 说明 二元 决策树 的 分类 情况 . 选择 159 种 股票 作为 样本 . 选择 股票 的 总资产 周转率 、 销售 增长率 、 净利 增长率 、 总资产 增长率 、 总资产 规模 、 总资产 净 利率 、 销售 净 利率 、 净资产 收益率 、 股东权益 比 作为 评价 标准 . 评价 结果 分为 三类 ， 分别 表示 绩优 、 垃圾 和 普通 这 三种 不同 的 股票 类别 . 
 　 　 选择 最小 错误率 I1 、 最小 分割 错误率 减少 量 I2 作为 参变量 ， 遗传算法 的 交叉 概率 、 变异 概率 、 迭代 次数 G 、 最小 分类 数 作为 固定值 ， 分别 为 0.9 ， 0.3 ， 100 ， 2 . 并 进行 了 多次 实验 ， 平均 结果 如表 1 所示 . 
 表 1 　 二元 决策树 分类 结果 
 
 最小 错误率 I1 最小 分割 错误率 减少 量 I2 错误 分类 数 错误 分类 率 
 0.050 . 038.725 . 48 ％ 
 0.050 . 022.841 . 78 ％ 
 0.050 . 010.690 . 43 ％ 
 0.040 . 034.102 . 57 ％ 
 0.040 . 022.141 . 34 ％ 
 0.040 . 010.520 . 33 ％ 
 0.030 . 021.981 . 25 ％ 
 0.030 . 010.450 . 28 ％ 
 0.020 . 021.350 . 85 ％ 
 0.020 . 010.360 . 23 ％ 
 
 　 　 最小 错误率 I1 和 最小 分割 错误率 减少 量 I2 直接 决定 二元 决策树 的 错误 分类 率 ， 从表 1 中 可以 看出 改变 最小 错误率 I1 和 最小 分割 错误率 减少 量 I2 ， 可以 控制 二元 决策树 的 错误 分类 率 ， 使 系统 成为 受控系统 . 
 6 　 结束语 
 　 　 文中 提出 了 用 遗传算法 构造 二元 决策树 的 方法 ， 并 对 遗传算法 进行 了 改进 ， 明显 地 提高 了 算法 的 收敛 速度 . 该 方法 提高 了 辨识 样本 的 准确率 和 速度 ， 为 样本 分类 提供 了 一种 简单 、 通用 、 有效 的 方法 . 文中 有 如下 特点 ： ① 遗传算法 的 改进 ； ② 遗传算法 求解 结点 的 权值 矢量 ； ③ 根据 树 结点 的 错误率 与 分割 后 的 错误率 减少 量 构造 二元 决策树 ； ④ 二元 决策树 的 错误 分类 率 可以 人为 控制 . 
 * 本 课题 得到 国家自然科学基金 资助 ( 项目编号 79670023 ) . 
 作者简介 ： 吴菲 ， 女 ， 1973 年 5 月生 ， 博士 研究生 ， 主要 研究 方向 为 遗传算法 、 自然语言 理解 、 智能 决策支持系统 . 
 　 　 　 　 　 黄 梯云 ， 男 ， 教授 ， 博士生 导师 ， 主要 研究 方向 为 决策支持系统 、 管理信息系统 . 
 作者 单位 ： 哈尔滨工业大学 管理 学院 　 哈尔滨 　 150001 
 参考文献 
 1 　 GoldbergD . GeneticAlgorithminSearch , OptimizationandMachineLearning . Reading , MA : Addison - Wesley , 1989 
 2 　 陈恩红 ， 王清毅 ， 蔡 庆生 . 基于 决策树 学习 中 的 测试 生成 及 连续 属性 的 离散 化 . 计算机 研究 与 发展 ， 1998 , 35 ( 5 ) ： 403 ～ 407 
 　 　 ( ChenEnhong , WangQingyi , CaiQingsheng . Testgenerationanddiscretizationofcontinuously - valuedattributesindecision - tree - basedlearning . JournalofComputerResearch & Development ( inChinese ) , 1998 , 35 ( 5 ) : 403 ～ 407 ) 
 3 　 肖勇 ， 陈意云 . 用 遗传算法 构造 决策树 . 计算机 研究 与 发展 ， 1998 , 35 ( 1 ) : 49 ～ 52 
 　 　 ( XiaoYong , ChenYiyun . Constructingdecisiontreesbyusinggeneticalgorithm . JournalofComputerResearch & Development ( inChinese ) , 1998 , 35 ( 1 ) : 49 ～ 52 ) 
 4 　 ChaiBB , HuangT , ZhuangXH , SklansyJ . Piecewiselinearclassifiersusingbinarytreestructureandgeneticalgorithm . PatternRecognition , 1996 , 29 ( 11 ) : 1905 ～ 1917 
 5 　 荚伟 等 . 遗传算法 在 软件测试 数据 生成 中 的 应用 . 北京航空航天大学 学报 ， 1998 , 24 ( 4 ) ： 434 ～ 437 
 　 　 ( JiaWeietal . Geneticalgorithmsandtheirapplicationinsoftware 　 testdatageneration . JournalofBeijingUniversityofAeronauticsandAstronautics ( inChinese ) , 1998 , 24 ( 4 ) : 434 ～ 437 ) 
 原稿 收到 日期 ： 1999 - 01 - 13 ； 修改稿 收到 日期 ： 1999 - 08 - 08 . 
