计算机 研究 与 发展 
 JOURNALOFCOMPUTERRESEARCHANDDEVELOPMENT 
 1999 　 Vol.36 　 No.7 　 P.805 - 812 
 
 
 
 总线 互连 机群系统 上 的 静态 任务调度 
 章军 　 冯 秀山 　 韩 冀中 　 韩 承德 
 摘 　 要 ： 与 大规模 并行处理 ( MPP ) 系统 相比 ， 基于 总线 互连 的 机群 ( cluster ) 系统 是 一种 较为 廉价 的 并行计算 环境 . 文中 提出 了 一个 基于 总线 互连 机群系统 上 的 静态 任务调度 算法 . 该 算法 具有 3 个 主要 特点 ： ( 1 ) 由于 不同 处理机 之间 的 通信 都 必须 通过 共享 总线 ， 故 在 调度 时 将 总线 与 处理机 一样 看成 是 资源 加以 分配 ； ( 2 ) 针对 总线 适合 于 广播 的 特点 ， 在 调度 中 考虑 了 广播 ， 对于 某些 应用 而言 可以 大大减少 通信 次数 ； ( 3 ) 在 确定 任务 在 某个 处理机 上 的 开始 执行 时间 以及 消息 占用 总线 的 开始 时间 时 ， 选用 了 最早 空闲 时间 空隙 . 最后 ， 分别 给出 了 Gauss - Jordan 消去法 与 LU 分解 的 任务 图 及其 调度 结果 . 
 关键词 ： 静态 任务调度 ， 机群 ， 有 向 无 环图 ， 任务 优先级 表 ， 空闲 时间 空隙 
 分类号 ： TP301.6 
 STATICTASKSCHEDULINGFORCLUSTERS 
 INTERCONNECTEDBYBUS 
 ZHANGJun 
 ( InstituteofComputingTechnology , ChineseAcademyofSciences , Beijing100080 ) 
 FENGXiu - Shan 
 ( InstituteofComputingTechnology , ChineseAcademyofSciences , Beijing100080 ) 
 HANJi - Zhong 
 ( InstituteofComputingTechnology , ChineseAcademyofSciences , Beijing100080 ) 
 HANCheng - De 
 ( InstituteofComputingTechnology , ChineseAcademyofSciences , Beijing100080 ) 
 Abstract ： Comparedwithmassivelyparallelprocessing ( MPP ) systems , acluster , whichconsistsofseveralcomputersinterconnectedbyabus , isaverycheapparallelcomputingenvironment . Thispaperproposesanovelschedulingalgorithmforclustersinterconnectedbybus . Ingeneral , thealgorithmhasthreemainfeatures : ( 1 ) Sharedbusistreatedasaresourcebeingallocatedtomessagesjustlikeprocessorstotasks ； ( 2 ) Broadcastisconsideredwhichcandecreasecommunicationtimesgreatlyinsomecases , and ( 3 ) Theearliestidletimeslotisexploitedwhendeterminingthestarttimeofataskonaprocessorandthatofamessageonthebus . Finally , thescheduleresultsoftheGauss - JordaneliminationmethodandLUdecompositionaregivenandanalyzed . 
 Keywords ： statictaskschedule , cluster , DAG , taskprioritylist , idletimeslot ▲ 
 1 　 引言 
 　 　 随着 微处理器 性能 以及 网络通信 带宽 的 显著 提高 ， 基于 总线 互连 的 机群系统 正 成为 适合 于 某些 应用 的 较为 廉价 的 并行计算 环境 . 
 　 　 为了 使 并行程序 在 机群系统 上能 得到 高效 地 执行 ， 必须 采用 合理 的 调度 技术 将 不同 的 任务 在 适当 的 时刻 分配 给 处理机 去 执行 . 对于 静态 任务调度 而言 ， 处理机 分配 给 任务 是 在 程序执行 之前 完成 的 . 有关 任务 的 计算 量 、 任务 之间 的 依赖 关系 及 通信 情况 、 每个 处理机 的 处理 能力 以及 它们 之间 的 互连 拓扑 在 编译 时 假定 是 已知 的 . 另外 ， 任务 一旦 分配 给 某个 处理机 ， 便 只能 在 该 处理机 上 执行 ， 即 任务 的 执行 是非 抢占 式 的 ( nonpreemptive ) . 一般说来 ， 静态 调度 的 主要 目标 是 最小化 整个 应用程序 的 执行 时间 . 
 　 　 近年来 ， 机群 计算 ( clustercomputing ) 正 成为 网络 并行计算 研究 的 热点 ， 主要 原因 有 如下 几点 ： ( 1 ) 只 需 两个 或 多个 工作站 ( PC机 ) 经 网络 互连 便 可 形成 机群系统 ， 几乎 无需 额外 投资 . 机群系统 为 并行计算 研究 提供 了 廉价 的 计算环境 ， 而 这种 计算环境 以前 只有 在 昂贵 的 并行机 上 才 具备 ； ( 2 ) 稳健 / 可靠 的 机群 软件 容易 获取 ， 如 MPICH 与 PVM 等 ； ( 3 ) 已经 出现 了 一些 用于 互连 多个 计算机 的 快速 网络 ， 如 ATM / Sonet , HiPPi , TokenRing 或 FDDI 等 . 
 　 　 本文 的 工作 给出 了 基于 总线 互连 机群系统 上 的 静态 任务调度 . 内容 的 介绍 分 3 个 部分 ， 第一 部分 介绍 了 调度 系统 模型 . 第二 部分 首先 讨论 了 调度 算法 中 的 几个 关键问题 的 解决方案 ， 然后 给出 了 调度 算法 ； 第三 部分 分别 给出 了 Gauss - Jordan 消去法 与 LU 分解 任务 图 及其 调度 结果 . 
 2 　 调度 系统 模型 
 　 　 调度 系统 模型 包含 任务模型 与 处理机 模型 . 本节 还 将 给出 基于 此 处理机 模型 的 静态 任务调度 问题 的 形式化 描述 . 
 2.1 　 任务模型 
 　 　 通常 ， 任务 依赖图 是 经 程序 划分 后 获得 的 ， 可用 图 理论 中 的 有 向 无 环图 ( directedacyclicgraph ， DAG ) 来 表示 ， 任一 有 向 无 环图 可用 四元组 TG = ( V , E , A , D ) 来 定义 . 其中 ， 
 　 　 ( 1 ) V = ［ vi ］ 表示 任务 图中 结点 ① 的 集合 ， vi 表示 第 i 个 任务 ， | V | 表示 图中 结点 数目 ； 
 　 　 ( 2 ) E = ［ ei , j ］ 表示 任务 图中边 ② 的 集合 ， ei , j 表示 由 vi 指向 vj 的 有 向 边 ， | E | 表示 图中边 的 数目 ； 
 　 　 ( 3 ) A = ［ ai ］ 表示 任务 的 计算 量 集合 ， ai 表示 任务 vi 的 计算 量 ； 
 　 　 ( 4 ) D = ［ di , j ］ 表示 任务 之间 通信 的 数据量 集合 ， di , j 表示 任务 vi 发送给 任务 vj 的 数据 的 大小 . 
 　 　 在 图 1 ( a ) 中 ， 对于 任意 结点 ， 上面 的 记号 表示 该 结点 的 名称 ， 下面 的 数值 表示 该 结点 的 计算 量 大小 ， 任务 与 任务 之间 的 通信 关系 用 有 向 边 来 表示 ， 有 向 边上 的 数值 表示 通信 的 数据量 大小 . 另外 ， 图中 的 bcst1 表示 任务 v1 向 任务 v2 , v3 , v4 , v5 广播 数据 ， bcst2 与 bcst3 的 含义 类推 . 
 
 　 　 　 　 
 图 1 　 调度 系统 模型 
 　 　 为了 表示 任务 之间 的 互相 依赖 情况 ， 下面 定义 图 TG 上 的 两个 优先 ( precedence ) 关系 及 ： 
 　 　 定义 1 . 在 图 TG 上 ， 如果 vi 是 vj 的 父 结点 ( 或 vj 是 vi 的 子 结点 ) ， 则 有 vivj ； 如果 vi 是 vj 的 祖先 结点 ( 或 vj 是 vi 的 子孙 结点 ) ， 则 有 vivj . 
 　 　 由 以上 定义 可知 ， 关系 具有 传递性 ， 而 关系 不 具有 传递性 . ei , j ∈ E 等价 于 vivj . 在 图 1 ( a ) 中 ， 有 v1v2 ， v1v6 等 满足 上述 两个 关系 . 
 　 　 在下文 中 ， 由 任务 vi 的 父 结点 和 祖先 结点 构成 的 集合 分别 记为 PARENT ( vi ) 与 PRED ( vi ) ， 而 由 任务 vi 的 子 结点 和 子孙 结点 构成 的 集合 分别 记为 CHILD ( vi ) 与 SUCC ( vi ) . 
 　 　 定义 2 . 在 任务 图 TG 中 ， 某 两个 任务 vi 与 vj 是 相互 独立 的 ( independent ) ， 当且 仅 当 viPRED ( vj ) 且 viSUCC ( vj ) ； 否则 vi 与 vj 是 相互依赖 的 ( dependent ) . 
 　 　 在 任务 图 TG 中 ， 如果 两个 任务 是 相互 独立 的 , 则 它们 可以 并行 地 执行 , 否则 , 只能 串行 地 执行 . 
 　 　 定义 3 . 对于 任务 vi ， 若 PARENT ( vi ) = , 则 vi 称之为 入 结点 ( entrynode ) , 记 集合 ENTRY = ｛ vi | PARENT ( vi ) = ｝ ； 若 CHILD ( vi ) = , 则 vi 称之为 出 结点 ( exitnode ) , 记 集合 EXIT = ｛ vi | CHILD ( vi ) = ｝ . 
 　 　 在 图 1 ( a ) 中 ， ENTRY = ｛ v1 ｝ , EXIT = ｛ v11 ｝ . 
 　 　 这种 任务 执行 模型 又 称之为 编译 时 的 宏 数据流 模型 ( compiletimemacrodataflowmodel ) ［ 1 ， 2 ］ . 在 该 模型 中 ， 每个 任务 只有 在 它 所 需要 的 数据 到 齐后 ， 才 可以 开始 执行 ， 即 任务 的 开始 执行 是 以 它 所 需要 的 数据 的 到 齐 驱动 的 ， 每个 任务 的 执行 都 是非 抢占 式 的 ， 任务 执行 完后 ， 立即 将 其 后代 所 需要 的 数据 发送给 它们 . 
 2.2 　 处理机 模型 
 　 　 本文 中 假定 所有 的 处理机 均 同构 . 对于 任一 以 总线 互连 的 机群系统 ， 其中 ， 
 　 　 ( 1 ) P = ［ pi ］ 表示 所有 处理机 的 集合 ， pi 表示 第 i 个 处理机 ， | P | 表示 处理机 的 数目 ； 
 　 　 ( 2 ) bus 为 连接 多个 处理机 的 共享 总线 . 
 　 　 在 图 1 ( b ) 中 ， 给出 了 一个 由 3 个 处理机 通过 同 一条 总线 互连 而成 的 机群系统 . 
 　 　 在 本文 中 ， 假定 每个 处理机 的 运算 速度 为 s ， 则 任务 图 TG 中 任务 vi 的 计算 时间 . 在 不 存在 总线 争用 ( buscontention ) 的 情况 下 ， 若 任务 vi 向 任务 vj 发送数据 量 的 大小 为 di , j ， 通信 延迟 可用 式 来 计算 ， 其中 ， α ， β 分别 表示 通信 时 的 启动 开销 、 总线 的 数据 传输率 . 
 　 　 本文 中 ， 假定 总线 是 半双工 的 ( halfduplex ) ， 即 在 总线 上 ， 一次 只能 允许 一个 通信 事务 ( communicationtransaction ) 的 发生 . 并且 ， 在 总线 上 发生 的 通信 是 可靠 无差错 的 . 另外 ， 每个 处理单元 都 带有 专门 的 硬件 来 支持 通信 ， 这样 的 部件 称为 I / O 处理机 . 这种 I / O 处理机 允许 任务 的 通信 与 计算 重叠 ( overlapping ) 地 进行 ， 即 一个 主 处理机 向 另 一个 主 处理机 发送 消息 时 ， 该主 处理机 只 需向 其 相应 的 I / O 处理机 发出 发送 消息 的 请求 ， 然后 立即 开始 下 一个 任务 的 计算 工作 ， 而 不是 在 确认 消息 已经 被 接收 后 ， 再 开始 下 一个 任务 的 计算 ， 具体 消息 的 发送 是 由 I / O 处理机 完成 的 . 另外 ， 当主 处理机 在 运行 时 ， 由 I / O 处理机 负责 接收 来自 其它 处理机 发送 来 的 消息 . 
 2.3 　 调度 问题 的 形式化 描述 
 　 　 在 以 总线 互连 的 机群系统 上 ， 调度 的 含义 有 两个 方面 ， 一方面 是 将 任务分配 给 处理机 去 执行 ， 另一方面 是 将 总线 分配 给 消息 去 使用 . 形式 地 ， 某个 调度 可用 函数 f 来 表示 ， 该 函数 的 定义域 为 V ∪ E ， 值域 为 P × ［ 0 , ∞ ) ∪ ［ 0 , ∞ ) . 对于 某个 任务 vi ∈ V ， 如果 f ( vi ) = ( pj , t ) ， 我们 便 称之为 ， 任务 vi 被 调度 到 处理机 pj 上 ， 并 在 t 时刻 开始 执行 ； 对于 某个 消息 ei , j , 如果 f ( ei , j ) = t ， 则 表示 在 t 时刻 总线 可以 分配 给 该 消息 ei , j 使用 . 
 　 　 对于 以 总线 互连 的 机群系统 ， 总线 是 有限 的 资源 ， 很 有 可能 出现 不同 的 消息 同时 争用 共享 总线 的 情况 . 因此 ， 如果 将 总线 也 作为 资源 来 静态 地 加以 分配 ， 在 程序运行 时 ， 便 不再 需要 考虑 总线 争用 问题 的 出现 . 
 　 　 衡量 调度 性能 的 最 主要 的 指标 是 调度 长度 ( schedulelength ， 文献 ［ 1 ］ 、 ［ 2 ］ 中 又 称之为 ParallelTime , 简称 PT ) ， 调度 f 的 调度 长度 PT ( f ) = max ｛ t + τ i ｝ ， 其中 f ( vi ) = ( pj , t ) ， 且 τ i = ai / s . 辅助 指标 有 算法 的 复杂度 及 需要 使用 的 处理机 的 个数 等 . 
 　 　 定义 4 . 在 由 无限 数目 的 处理机 构成 的 完全 互连 同构 系统 上 ， 若 将 任务 图 TG 中 不同 的 任务 映射 到 不同 的 处理机 上 ， 任务 图 TG 中 的 静态 关键 路径 ( staticgriticalpath , 记作 SCP ) 定义 为 从入 结点 到 出 结点 中 最长 的 路径 ( 包含 任务 之间 的 通信 时间 ) . 任一 结点 vx 的 toplevel ( 记作 tlevel ) 定义 为 从入 结点 到 该 结点 ( 不 包含 该 结点 的 权 ) 的 最长 路径 的 长度 ( 记作 tlevel ( vx ) ) . 任一 结点 的 bottomlevel ( 记作 blevel ) 定义 为 从 该 结点 到 出 结点 ( 包含 该 结点 的 权 ) 的 最长 路径 的 长度 ( 记作 blevel ( vx ) ) . 
 　 　 在下文 中 ， 由 静态 关键 路径 上 的 结点 构成 的 集合 记为 SCPN . 对于 图 1 ( a ) ， 在 处理机 个数 等于 11 的 全 互连 同构 系统 上 ， 当 不同 的 任务 被 映射 到 不同 的 处理机 上时 ， 若 s = 1 , α = 0 , β = 1 , 则 该 任务 图中 的 静态 关键 路径 为 v1v4v7v9v11 ， 即图 1 ( a ) 中 的 粗 黑线 , SCPN = ｛ v1 , v4 , v7 , v9 , v11 ｝ . 
 　 　 在 由 无限 数目 的 处理机 构成 的 完全 互连 同构 系统 上 ， 若 将 任务 图 TG 中 不同 的 任务 映射 到 不同 的 处理机 上 ， SCP 的 长度 为 maxvx ∈ V ｛ tlevel ( vx ) + blevel ( vx ) ｝ ， 任意 结点 vi 的 tlevel 与 blevel 的 计算方法 如下 : 
 
 　 　 直观 地 ， 一个 结点 的 tlevel 值越 小 ， 则 说明 该 结点 越有 可能 先 被 调度 ； 一个 结点 的 blevel 值越 大 ， 则 说明 该 结点 越应 先 被 调度 . 
 3 　 调度 算法 介绍 
 　 　 就 作者 们 所知 ， 在 目前 发表 的 为数不多 的 基于 非 完全 互连 系统 上 的 静态 任务调度 文章 ［ 3 ， 4 ］ 中 , 尚 没有 一篇 文章 讨论 基于 总线 互连 机群系统 上 的 静态 任务调度 问题 . 本文 中 所 讨论 的 基于 总线 互连 的 机群系统 上 的 静态 任务调度 算法 至少 有 两点 不同于 其他 非 完全 互连 系统 上 的 静态 任务调度 算法 . 第一 ， 由于 总线 适合 于 广播 ， 在 调度 中 考虑 了 广播 问题 ③ ， 对于 某些 应用 而言 可以 大大减少 通信 次数 ； 第二 ， 在 确定 消息 占用 总线 的 开始 时间 时 ， 选用 了 最早 空闲 时间 空隙 . 
 　 　 在下文 给出 的 调度 算法 中 ， 直接 将 实际 的 处理机 与 总线 看成 是 资源 ， 任务 与 消息 看成 是 消费者 ， 同时 考虑 如何 将 处理机 分配 给 任务 以及 如何 将 总线 分配 给 消息 . 
 　 　 基于 总线 互连 机群系统 的 静态 任务调度 中要 解决 的 问题 有 3 个 ： 如何 顺序 选择 参与 调度 的 任务 ； 如何 将 总线 的 空闲 时间 空隙 分配 给 消息 ； 以及 如何 将 处理机 分配 给 任务 . 下面 将 讨论 这 3 个 问题 的 解决方案 ， 最后 给出 调度 算法 . 
 　 　 ( 1 ) 如何 顺序 选择 参与 调度 的 任务 
 　 　 本文 中 总是 优先 调度 关键 路径 上 的 任务 . 在 确定 关键 路径 时 ， 有些 算法 采用 的 是 静态 关键 路径 ， 而 有些 算法 采用 的 是 动态 关键 路径 . 通常 ， 后 一类 算法 产生 的 调度 长度 短于 前 一类 算法 产生 的 调度 长度 ， 但前 一类 算法 的 复杂度 低于 后 一类 算法 的 复杂度 . 在 本文 中 ， 为了 降低 算法 的 复杂度 ， 采用 的 是 静态 关键 路径 . 对于 非关键 路径 上 的 任务 总是 优先 考虑 slevel = blevel - tlevel 值越 大 的 任务 . 在 任务调度 中 ， 任务 的 选择 总是 按 拓扑 顺序 进行 的 . 在 下面 的 算法 中 给出 了 一个 建立 任务 优先级 表 的 算法 . 在 算法 的 实现 中 ， 需 增加 两个 虚 结点 ， 通过 第一个 虚 结点 ( 即 下面 算法 中 的 v0 ) 可以 访问 所有 的 入 结点 ， 通过 第二个 虚 结点 可以 访问 所有 的 出 结点 . 
 　 　 算法 1 . 创建 任务 优先级 表 
 　 　 ① 从 集合 ｛ vi | v0vi ∧ vi ∈ SCPN ｝ 中 选择 任一 结点 ve ， 使 之 成为 任务 优先级 表中 第一个 任务 . 
 　 　 ② 从 结点 ve 的 子 结点 中 选择 一个 位于 静态 关键 路径 上 的 结点 作为 下 一个 候选 结点 vi ， 如果 有 多个 这样 的 子 结点 ， 则 选择 与 结点 ve 有 最大 通信 的 子 结点 . 
 　 　 ③ if 结点 vi 的 所有 父 结点 都 在 任务 优先级 表中 then 
 　 　 ④ 将 结点 vi 置于 任务 优先级 表 的 表尾 . 
 　 　 ⑤ else 
 　 　 ⑥ 假定 vj 是 结点 vi 的 那些 不 在 任务 优先级 表中 的 父 结点 之一 且 vj 在 这些 父 结点 中 具有 最大 的 slevel 值 . 如果 有 多个 这样 的 父 结点 ， 则 选择 与 结点 vi 有 最大 通信 的 结点 . 如果 vj 的 父 结点 都 在 任务 优先级 表中 , 则 将 结点 vj 置于 任务 优先级 表 的 表尾 . 否则 递归 地 将 vj 的 所有 父 结点 放入 到 任务 优先级 表中 . 
 　 　 ⑦ 重复 第 ⑥ 步 直到 vi 的 所有 父 结点 都 在 任务 优先级 表中 ， 再 将 vi 置于 任务 优先级 表 的 表尾 . 
 　 　 ⑧ endif 
 　 　 ⑨ 从 结点 vi 的 子 结点 中 选择 一个 位于 静态 关键 路径 上 的 结点 作为 下 一个 候选 结点 vi ， 如果 有 多个 这样 的 子 结点 ， 则 选择 与 结点 vi 有 最大 通信 的 子 结点 . 
 　 　 ⑩ 重复 ③ ～ ⑨ 步 ， 直到 所有 的 结点 进入 任务 优先级 表 . 
 　 　 很 容易 证明 ， 由 以上 算法 建立 的 任务 优先级 表 总是 满足 拓扑 顺序 的 ， 因为 每个 任务 只有 在 它 所有 的 父 任务 入表后 ， 才 入表 . 对于 图 1 ( a ) , 在 s = 1 , α = 0 , β = 1 时 , 建立 的 任务 优先级 表为 v1 , v4 , v2 , v7 , v3 , v6 , v9 , v5 , v8 , v10 , v11 . 
 　 　 ( 2 ) 如何 将 总线 的 空闲 时间 空隙 分配 给 消息 
 　 　 在 本文 中 ， 消息 使用 总线 服从 先来 先 服务 的 排队 原则 . 在 确定 消息 使用 总线 时 ， 选用 的 是 最早 空闲 时间 空隙 . 
 　 　 下面 给出 消息 ei , j 可以 使用 总线 的 最早 时间 ST ( ei , j ) 的 计算方法 . 假定 任务 vi 被 调度 到 处理机 pm 上 执行 ， 而 任务 vj 被 调度 到 处理机 pn 上 执行 且 pm ≠ pn ， FT ( vi , pm ) 为 任务 vi 在 处理机 pm 上 的 完成 时间 . 另外 ， 此前 已有 δ 个 消息 ｛ msg1 , msg2 , … , msg δ ｝ 要求 使用 总线 ， 它们 所 占用 的 时间 空隙 ITS ( bus ) = ［ η 1 , ζ 1 ］ ∪ ［ η 2 , ζ 2 ］ ∪ … ∪ ［ η δ ， ζ δ ］ . 因为 存在 一些 k 满足 下 式 ， 
 　 　 ( 1 ) 
 其中 ， k = 0 , … , δ ， ζ 0 = 0 ， η δ + 1 = ∞ . 
 　 　 可知 , 至少 k = δ 是 满足 不等式 ( 1 ) 的 ， 假定 l 是 所有 k 中 满足 上述 不等式 的 最小值 ， 则 
 ST ( ei , j ) ＝ max ｛ ζ l , FT ( vi , pm ) + α ｝ 　 　 ( 2 ) 
 　 　 则 消息 ei , j 到达 处理机 pn 的 时间 
 　 　 ( 3 ) 如何 将 处理机 分配 给 任务 
 　 　 本文 中 主要 考虑 选择 使 任务 最早 开始 执行 的 处理机 . 
 　 　 下面 给出 任务 vi 在 处理机 pm 上 的 最早 开始 执行 时间 ST ( vi , pm ) 的 计算方法 . 定义 LDAT ( vi , pm ) 为 任务 vi 被 调度 到 处理机 pm 上时 ， 消息 集合 ｛ ex , i | vxvi ｝ 中 最晚 到达 处理机 pm 的 消息 到达 的 时间 . 假定 在 任务 vi 分配 给 处理机 pm 时 已有 δ 个 任务 ｛ vm1 , vm2 , … , vm δ ｝ 要求 顺序 使用 处理机 pm . 因为 存在 一些 k 满足 下 式 ， 
 　 　 ( 3 ) 
 其中 ， k = 0 , … , δ ， ST ( vm0 , pm ) = 0 ， ST ( vm δ + 1 , pm ) = ∞ . 
 　 　 可知 , 至少 k = δ 是 满足 不等式 ( 3 ) 的 ， 假定 l 是 所有 k 中 满足 上述 不等式 的 最小值 ， 则 
 ST ( vi , pm ) = max ｛ ST （ vml , pm ） + τ ml , LDAT ( vi , pm ) ｝ 　 　 　 ( 4 ) 
 　 　 在 图 2 中 ， 假定 已有 任务 v1 , v2 , v3 , v4 调度 到 处理机 p 上 ， 若 将 任务 v5 调度 到 处理机 p 上时 ， 任务 v5 所 需要 的 数据 最 晚 到达 处理机 p 的 时刻 为 1.3 . 现在 ， 任务 v5 的 执行 时间 为 0.5 ， 而 处理机 p 上 存在 的 空闲 时间 空隙 为 ［ 1.7 , 1.9 ］ , ［ 2.5 , 3.1 ］ 及 ［ 5.1 , ∞ ］ ， 则 任务 v5 在 处理机 p 上 的 最早 开始 时刻 为 2.5 . 在下文 中 ， 记 处理机 p 上 的 空闲 时间 空隙 集合 为 ITS ( p ) ， 记 P ( vi ) 为 分配 给 任务 vi 的 处理机 . 
 
 
 图 2 　 任务 如何 占用 处理机 上 的 最早 空闲 时间 空隙 
 　 　 其实 ， 将 总线 上 的 最早 空闲 时间 空隙 分配 给 消息 的 思想 与 将 处理机 上 的 最早 空闲 时间 空隙 分配 给 任务 的 思想 是 类似 的 . 
 　 　 在 解决 了 以上 3 个 问题 后 ， 下面 给出 调度 算法 的 描述 . 
 　 　 算法 2 . 调度 算法 
 　 　 ( 1 ) 初始化 . 
 　 　 　 　 ① vi ∈ V , 计算 tlevel ( vi ) , blevel ( vi ) , slevel ( vi ) ； 
 　 　 　 　 ② 计算 任务 图 的 串行 计算 时间 ； 
 　 　 　 　 ③ pi ∈ P ， 赋 ITS ( pi ) 为 ［ 0 , ∞ ］ ； 
 　 　 　 　 ④ 对于 总线 ， 赋 ITS ( bus ) 为 ［ 0 , ∞ ］ . 
 　 　 ( 2 ) 创建 任务 优先级 表 . 
 　 　 ( 3 ) 从 任务 优先级 表中取 第一个 任务 ， 假定 它 为 vj 并 将 被 调度 到 处理机 pn 上 , vi ∈ V ∧ vivj , 计算 ST ( ei , j ) 与 RT ( ei , j ) . 具体 分 3 种 情况 来 考虑 ： 
 　 　 　 　 ① 若 pn = P ( vi ) ， 则 RT ( ei , j ) = ST ( ei , j ) = FT ( vi , P ( vi ) ) . 
 　 　 　 　 ② 若 ei , j 是 广播 消息 . 如果 消息 ei , j 已 被 广播 ， 则 RT ( ei , j ) , ST ( ei , j ) 已 被 计算 ； 否则 广播 消息 ei , j ， 并 根据 式 ( 1 ) 、 ( 2 ) 计算 ST ( ei , j ) ， 从而 算得 RT ( ei , j ) . 
 　 　 　 　 ③ 直接 根据 式 ( 1 ) 、 ( 2 ) 计算 ST ( ei , j ) ， 从而 算得 RT ( ei , j ) . 
 　 　 ( 4 ) 根据 所有 的 RT ( ei , j ) ， 计算 LDAT ( vj , pn ) = maxvivj ｛ RT ( ei , j ) ｝ ， 再 根据 式 ( 3 ) 、 ( 4 ) 计算 ST ( vj , pn ) . 
 　 　 ( 5 ) pn ∈ P ， 根据 ( 3 ) ～ ( 4 ) 步 计算 ST ( vj , pn ) . 设 ST ( vj , pc ) = minpn ∈ PST ( vj , pn ) . 如果 有 多个 处理机 满足 此 条件 ， 则 任选 其中 一个 处理机 作为 pc . 
 　 　 ( 6 ) 计算 任务 vj 在 处理机 pc 上 的 完成 时间 FT ( vj , pc ) ， 如果 FT ( vj , pc ) 超出 了 程序 的 串行 时间 ， 则 将 所有 的 任务调度 到 一个 处理机 上去 执行 并 退出 调度 . 
 　 　 ( 7 ) ① 修改 ITS ( pc ) ； 
 　 　 　 　 ② 修改 ITS ( bus ) ； 
 　 　 　 　 ③ 从 任务 优先级 表 中将 任务 vj 删除 . 
 　 　 ( 8 ) 重复 ( 3 ) ～ ( 8 ) 步 ， 直到 所有 的 任务 都 调度 完毕 . 
 　 　 在 图 1 中 ， 将 ( a ) 图 的 任务 图 调度 到 ( b ) 图中 的 以 总线 互连 的 机群系统 上时 ， 根据 以上 调度 算法 产生 的 实际 调度 结果 见图 ( c ) ， 在 该 图 中 ， 分别 给出 了 处理机 与 总线 的 使用 情况 . 例如 ， 任务 v3 在 1 时刻 被 调度 到 处理机 p2 上 执行 ， 消息 e8 , 10 在 时间 ［ 5 , 5.4 ］ 使用 总线 . 由 调度 结果 可知 ， 该 任务 图 的 串行 执行 时间 为 22 ， 不 考虑 任务 之间 通信 时间 的 最大 路径 长度 ④ 为 11.5 ， 本 算法 产生 的 调度 长度 为 13 . 值得 指出 的 是 ， 任务 v5 被 插 到 任务 v4 与 任务 v7 之间 并 紧随 任务 v4 之后 执行 ， 另外 ， 消息 e5 , 8 被 插 到 bcst2 之前 使用 总线 . 
 　 　 在 上述 算法 中 ， 最 主要 的 时间 花 在 ( 3 ) ～ ( 7 ) 步 . 对于 每个 任务 ， 都 要 计算 该 任务 在 每个 处理机 上 的 最晚 消息 的 到达 时间 以及 寻找 相应 的 最早 空闲 时间 空隙 . 故该 算法 的 复杂度 为 O ( ｜ V ‖ E ‖ P ｜ ) . 
 4 　 模拟 试验 
 　 　 Gauss - Jordan 消去法 与 LU 分解 是 两种 较为 常见 的 数值 计算方法 . 在 以下 试验 中 ， 假定 处理机 的 运算 速度 为 50Mflops ， 浮点 加减 与 乘除 均 花费 一个 时钟 周期 . 另外 ， 通信 时 的 启动 开销 为 0.5 ms ， 总线 的 数据 传输率 为 每秒 100 , 000 个 浮点数 . 下面 给出 它们 的 任务 图及 调度 结果 . 
 4.1 　 Gauss - Jordan 消去法 
 　 　 图 3 ( a ) 是 在 不 考虑 选主元 情况 下 Gauss - Jordan 消去法 的 DAG 图 . 假定 该 矩阵 大小 为 10000 × 10000 ， 分块 矩阵 的 大小 为 200 × 200 ， 故 在 该 任务 图 中共 有 1327 个 任务 . 图中 每个 任务 的 计算 量 大小 以及 任务 之间 通信量 的 大小 可 由 手工 分析 得出 ， 计算 获得 任务 图 的 串行 执行 时间 为 18835.06 s ， 由入 结点 到 出 结点 中 不 考虑 任务 之间 通信 时间 的 最大 路径 长度 为 768.68 s . 在 图 3 ( b ) 中 ， 任务 vi + 1i 向 所有 的 任务 vji + 1 ( 其中 ， 0 ≤ i ≤ 49 , i + 1 < j ≤ 51 ) 广播 相同 的 数据 . 如能 利用 广播 ， 在 最好 可能 情况 下 ， 节省 的 通信 次数 可为 1225 次 . 在 图 4 ( a ) 中 ， 给出 了 运行 调度 程序 获得 的 加速 比 与 处理机 个数 的 关系 图 ， 其中 加速 比 等于 串行 时间 除以 调度 长度 . 总的来说 ， 由于 利用 了 广播 ， 节省 了 通信 次数 ， 随着 处理机 个数 的 增加 ， 加速 比 呈 线性 增长 的 趋势 并 逐渐 减慢 . 如果 不 利用 广播 ， 在 处理机 个数 为 2 时 调度 获得 的 加速 比 最大 ， 仅为 1.48 . 此后 ， 即使 增加 处理机 个数 ， 加速 比 也 不能 增加 ， 因为 总线 已 成为 通信 的 瓶颈 . 
 
 
 图 3 　 Gauss - Jordan 消去法 的 任务 图 ( a ) 与 LU 分解 的 任务 图 ( b ) 
 
 
 图 4 　 Gauss - Jordan 消去法 的 调度 结果 ( a ) 与 LU 分解 的 任务 图 ( b ) 
 4.2 　 LU 分解 
 　 　 图 3 ( b ) 是 在 不 考虑 选主元 情况 下 LU 分解 ［ 5 ］ 的 DAG 图 . 假定 该 矩阵 大小 为 10000 × 10000 ， 分块 矩阵 的 大小 为 200 × 200 ， 故 在 该 任务 图 中共 有 1275 个 任务 . 图中 每个 任务 的 计算 量 大小 以及 任务 之间 通信量 的 大小 可 由 手工 分析 得出 ， 计算 获得 任务 图 的 串行 执行 时间 为 13337.62 s ， 由入 结点 到 出 结点 中 不 考虑 任务 之间 通信 时间 的 最大 路径 长度 为 606.41 s . 在 图 3 中 ， 任务 vii 向 所有 的 任务 vji ( 其中 ， 1 ≤ i ≤ 49 , i + 1 ≤ j ≤ 50 ) 广播 相同 的 数据 . 如能 利用 广播 ， 在 最好 可能 情况 下 ， 节省 的 通信 次数 可为 1176 次 . 在 图 4 中 ， 给出 了 运行 调度 程序 获得 的 加速 比 与 处理机 个数 的 关系 图 . 总的来说 ， 随着 处理机 个数 的 增加 ， 加速 比 呈 线性 增大 的 趋势 并 逐渐 减慢 . 另外 ， 图中 还 出现 了 波动 现象 . 经 分析 ， 这 是因为 在 处理机 个数 较多时 ， 一 开始 任务 便 分散 到 不同 的 处理机 上去 ， 导致 以后 调度 产生 的 通信 开销 较大 . 如果 不 利用 广播 ， 在 处理机 个数 为 2 时 调度 获得 的 加速 比 最大 ， 仅为 1.64 . 
 5 　 结束语 
 　 　 任务调度 问题 是 经典 的 NP 问题 . 本文 首次 给出 了 一个 基于 总线 互连 机群系统 上 的 静态 任务调度 算法 并 首次 在 任务调度 中 考虑 了 广播 问题 . 文章 的 最后 分别 给出 了 Gauss - Jordan 消去法 与 LU 分解 的 任务 图及 相应 的 调度 结果 . 通过 模拟 试验 表明 ， 虽然 总线 在 并行计算 中 往往 容易 成为 通信 的 瓶颈 ， 但 如能 充分利用 总线 的 广播 特性 ， 对于 像 Gauss - Jordn 消去法 及 LU 分解 这样 的 算法 ， 仍能 取得 满意 的 性能 . ■ 
 ① 任务 图中 的 结点 即 指 任务 ， 故 在 本文 中 有时 结点 与 任务 混用 
 ② 任务 图中 的 边 即 指 消息 ， 故 在 本文 中 有时 边 与 消息 混用 
 ③ 文献 ［ 2 ］ 在 代码生成 阶段 考虑 广播 问题 ， 而 本文 是 在 调度 阶段 考虑 广播 问题 的 . 
 ④ 这是 调度 的 极限 ， 即使 最优 调度 长度 也 不能 小于 此值 . 
 基金项目 ： 本 课题 得到 国家 自然科学 资金 ( 项目编号 69896250 ) 与 “ 九五 ” 中国科学院 基础性 　 　 　 　 　 　 研究 重大项目 ( 项目编号 KJ - 951 - B1 - 703 ) 的 资助 . 
 作者简介 ： 章军 ， 男 ， 1971 年 3 月生 ， 博士 研究生 , 主要 研究 方向 为 并行计算 、 并行 任务调度 、 　 　 　 　 　 　 计算机 体系结构 等 . 
 　 　 　 　 　 冯 秀山 ， 男 ， 1973 年 11 月生 ， 硕士 研究生 , 主要 研究 方向 为 数字 信号处理 、 计算机 　 　 　 　 　 　 体系结构 等 . 
 　 　 　 　 　 韩 冀中 ， 男 ， 1972 年 7 月生 ， 博士 研究生 , 主要 研究 方向 为 数字 信号处理 、 计算机 体 　 　 　 　 　 　 系 结构 等 . 
 　 　 　 　 　 韩 承德 , 男 ， 1940 年 4 月生 ， 研究员 , 博士生 导师 , 主要 研究 方向 为 计算机 体系 结 　 　 　 　 　 　 构 、 计算机 并行处理 、 多媒体技术 等 . 
 作者 单位 ： 章军 ( 中国科学院计算技术研究所 　 北京 　 100080 ) 
 　 　 　 　 　 冯 秀山 ( 中国科学院计算技术研究所 　 北京 　 100080 ) 
 　 　 　 　 　 韩 冀中 ( 中国科学院计算技术研究所 　 北京 　 100080 ) 
 　 　 　 　 　 韩 承德 ( 中国科学院计算技术研究所 　 北京 　 100080 ) 
 参考文献 ： 
 ［ 1 ］ HwangJJetal . Schedulingprecedencegraphsinsystemswithinterprocessorcommunicationtimes , SIAMJComput , 1989 , 18 ( 2 ) : 244 ～ 257 
 ［ 2 ］ YangTetal . PYRROS : Staticschedulingandcodegenerationformessagepassingmultiprocessors . In : Proc6thACMIntConfSC ' 92 , 1992.428 ～ 437 
 ［ 3 ］ HeshamEl - Rewinietal . Schedulingparallelprogramtasksontoarbitrarytargetmachines . JournalofParallelandDistributedComputing , 1990 , 9 : 138 ～ 153 
 ［ 4 ］ Yu - KwongKwoketal . Bubblescheduling : Aquasidynamicalgorithmforstaticallocationoftaskstoparallelarchitectures . In : IEEESymposiumonParallelandDistributedProcessing , 1995 . http : / / www . cs . ust . hk 
 ［ 5 ］ DongarraJJ , WalkerDW . Constructingnumericalsoftwarelibrariesforhighperformancecomputerenvironments . In : AlbertYHZomayaed . Parallel & DistributedComputingHandbook . NewYork : McGraw - Hill.1996 : 917 ～ 954 
 收稿 日期 ： 1998 - 10 - 27 
 修稿 日期 ： 1999 - 03 - 29 
