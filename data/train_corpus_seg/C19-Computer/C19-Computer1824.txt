微型机 与 应用 
 MICROCOMPUTER & ITSAPPLICATIONS 
 2000Vol.19 No.2 P.7 - 9 
 
 
 
 
 利用 定点数 进行 数值 运算 
 朱丹 绯 　 顾钟文 　 周 春晖 
 摘要 ： 利用 80387 指令 和 C ＋ ＋ 提供 的 面向对象 的 特性 ， 构造 了 定点数 类 ， 可以 代替 浮点数 进行 数值 计算 ， 能 有效 防止 在 运算 中 出现 协处理器 的 浮点 异常 。 
 关键词 ： 定点 浮点 数值 计算 80387 指令 
 　 　 当前 ， 大量 的 数值 计算 程序 已经 用 C ／ C ＋ ＋ 语言 开发 ， 运行 于 PC机 的 WIN32 环境 ， 然而 ， 在 此 环境 下用 浮点数 进行 运算 时 可能 产生 溢出 、 下溢 等 异常 ， 使 程序 退出 运行 。 一般 的 数值 计算 程序 可以 从中 知道 算法 的 错误 ， 但 对于 控制 和 仿真 培训 领域 ， 如果 控制算法 或 仿真 数学模型 运行 中 出现异常 使 程序 终止 运行 ， 就 会 带来 不良后果 ； 而 如果 用 屏蔽 异常 的 方法 ， 当 发生 溢出 时 ， 运算 结果 由 80387 设置 ， 在 随后 的 运算 中 可能 产生 更 严重 的 异常 。 为此 ， 本文 开发 了 一种 定点数 类 ， 用于 代替 浮点数 进行 运算 ， 能 避免出现 上述 问题 。 由于 浮点数 运算 和 这个 定点数 类 的 实现 都 依赖 80387 指令 ， 故 下面 先对 80387 作一 介绍 。 
 180387 简介 
 1 ． 1 浮点数 格式 
 　 　 在 计算机 里 ， 用来 表示 数 的 位数 是 有限 的 ， 所以 计算机 不能 精确 地 表示 出 所有 的 实数 ， 而 只能 表示 无穷 个 实数 的 一个 极小 的 子集 。 这个 子集 在 一般 情况 下 已经 可以 解决 绝大多数 的 实际 问题 ， 而且 丢掉 的 精度 也 是 微不足道 的 。 实数 的 表示 方法 有 2 种 ： 定点数 和 浮点数 。 定点数 比较简单 ， 以 一个 整数 来 实现 ， 只不过 规定 了 其中 几位 是 小数 部分 ， 它 所能 表示 的 数 的 范围 不 大 而且 是 固定 不变 的 ； 浮点数 可以 使 二进制 小数点 浮动 ， 它 有 专门 用来 规定 小数点 位置 的 部分 ， 还有 用来 表示 数据 有效数字 的 部分 ， 这样 在 保证 精度 的 同时 ， 还 可以 有效 地 拓展 数 的 表示 范围 。 
 　 　 80387 作为 浮点 处理器 ， 能 处理 多种 整数 与 浮点数 ， 如表 1 所示 。 
 　 　 在 3 种 浮点数 中 ， 短型 实数 和 长型 实数 是 IEEE754 标准 所 定义 的 ［ 2 ］ ， 而 临时 型 实数 是 80387 内部 的 格式 ， 无论 给出 什么样 类型 的 数 ， 在 80387 内部 都 将 它们 转化成 临时 型 实数 ， 由于 临时 型 实数 精度高 ， 用 这种 方法 ， 可以 提高 运算 精度 ， 扩大 运算 范围 。 3 种 浮点数 格式 如表 2 所示 。 
 　 　 这 3 种 实数 分别 对应 于 C语言 中 的 float 、 double 和 longdouble 类型 。 
 　 　 有效数字 有时 被 称为 尾数 。 在 80387 的 实数 表示法 中 ， 规定 任何 实数 只能 用 下面 的 格式 表示 ： 
 　 　 1 ． xxxx × 2n （ x 表示 1 或 0 ） 
 表 180387 支持 的 数据类型 ［ 1 ］ 
 数据类型 位 有效数字 大致 范围 （ 十进制 ） 
 字 的 整数 164 － 32768 ≤ X ≤ 32767 
 短型 整数 329 － 2 × 109 ≤ X ≤ 2 × 109 
 长 型 整数 6418 － 9 × 1018 ≤ X ≤ 9 × 1018 
 压缩 十进制 （ BCD ） 8018 － 99 .. 99 ≤ X ≤ 99 .. 99 熓 八位 ） 
 短型 实数 326 - 7 － 3 ． 39 × 1038 ≤ X ≤ 3 ． 39 × 1038 
 长 型 实数 6415 - 16 － 1.80 × 10308 ≤ X ≤ 1.80 × 10308 
 临时 型 实数 8019 － 1.19 × 104932 ≤ X ≤ 1.19 × 104932 
 表 2 浮点数 格式 [ 1 ] 
 数据类型 犠 芪 皇 符号 位指 数字 段 有效数字 段 
 短型 实数 321823 
 长 型 实数 6411152 
 临时 型 实数 8011564 
 表 380387 的 异常 
 代码 状态 位 屏蔽 位 条件 
 I ， ISIEIM 无效 操作 
 DDEDM 微小 数 
 ZZEZM 被 零除 
 OOEOM 溢出 
 UUEUM 下溢 
 PPEPM 精度 
 　 　 在 二进制 小数 的 左边 ， 有且 仅 有 1 位 1 ， 于是 有 尾数 规则 ： 在 实数 的 表示 中省 下 这个 “ 1 ” ， 节约 的 1 位 可以 用来 提高 精度 。 但是 ， 临时 型 实数 没有 隐藏 位 ， 1 个 格式化 的 临时 型 实数 中 第 63 位 永远 为 1 。 另外 ， 在 任何 一种 实数 表示 中 ， 零 的 偏移 指数 和 有效数字 都 为 0 ， 所以 可以 从 临时 型 实数 的 第 63 位来 判断 实数 是否 为 零 。 
 1 ． 2 异常 
 　 　 80387 的 各类 异常 如表 3 所示 。 
 　 　 在 数值 计算 程序 中 ， 无效 操作 、 被 零除 是 可以 避免 的 ， 而 精度 及 微小 数 异常 并 不是 真的 异常 ， 只是 数值 计算 中有 精度 损失 的 一个 警告 ， 一般 都 会 处于 屏蔽 状态 ， 所以 ， 关键在于 解决 溢出 及 下溢 异常 。 由于 定点数 本质 是 整数 ， 不 存在 下溢 的 情况 ， 对于 溢出 ， 可以 在 程序 中 用 限幅 来 解决 ， 在 控制 和 仿真 培训 软件 中 ， 这种 限幅 一般 是 合理 的 ， 不会 对 计算 产生 坏 的 影响 。 所以 用 定点数 计算 就 可能 避免 一切 浮点 异常 。 
 2 定点数 的 实现 
 　 　 高效 定点数 实现 方法 需要 处理器 的 直接 支持 ， 由于 80386 支持 的 最大 整数 为 32 位 ， 用 32 位 整数 作 定点数 显然 精度 太低 ， 所以 至少 要用 80387 支持 的 64 位 整数 。 用 64 位 整数 ， 以高 双字 来 表示 整数 部分 ， 低 双字 表示 小数 部分 ， 用来 做 控制 和 仿真 运算 ， 精度 基本 能 达到 要求 。 在 BorlandC ＋ ＋ 5 ． 02 版本 以上 提供 了 ＿ int64 关键字 ， 于是 可以 在 定点数 类中 直接 声明 1 个 64 位 整数 变量 i64 ， 考虑 到 编程 的 方便 ， 另设 1 个 结构 i32 ， 包含 2 个 32 位 整数 ， 再 将 此 结构 与 i64 作 联合 ， 这样 做 的 另 一个 目的 是 方便 调试 ， 因为 如果 在 调试 中 只 看到 变量 i64 的 值 ， 很难 知道 定点数 对应 的 实数 应该 是 多少 ， 而 如果 能 分别 看到 定点数 的 整数 和 小数 部分 ， 就 能 知道 对应 实数 大致 的 值 。 定点数 的 完整 定义 如下 ： 
 classfixed 
 ｛ 
 　 public ： 
 　 　 　 　 union 
 　 　 　 　 ｛ 
 　 　 　 　 　 ＿ int64i64 ； 
 　 　 　 　 　 　 　 struct 焨 nsignedlonglow ； longhigh ； 爄 32 ； 
 　 　 　 　 　 ｝ ； 
 　 　 　 　 　 ＿ fastcallfixed 　 （ ） ｛ i64 ＝ 0 ； ｝ 
 　 　 　 　 　 ＿ fastcallfixed （ constfixed ＆ f ） 煟 鹖 64 ＝ f ． i64 ； ｝ 
 　 　 　 　 　 ＿ fastcallfixed （ longh ， unsignedlong1 ＝ 0 ） ｛ i32 ． 
 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 high ＝ h ； i32 ． low ＝ 1 ； ｝ 
 　 　 　 　 ＿ fastcallfixed （ longdouble ） ； 
 　 　 　 　 　 ＿ fastcalloperatorlongdouble （ ） const ； 
 　 　 　 　 　 fixed ＆ ＿ fastcalloperator ＝ （ longdoubleld ） ｛ fixed 
 　 　 　 　 　 　 　 　 　 　 　 　 　 　 tmp （ ld ） ； i64 ＝ tmp ． i64 ； return * this ； ｝ 
 　 　 　 　 　 fixed ＿ fastcalloperator ＋ （ ） const ｛ return * this ； ｝ 
 　 　 　 　 fixed ＿ fastcalloperator － （ ） const ｛ fixedtmp （ * this ） ； 
 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 tmp ． i64 ＝ － i64 ； returntmp ； ｝ 
 　 　 　 　 　 fixed ＆ ＿ fastcalloperator ＋ ＝ （ constfixed ＆ f ） 
 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ｛ i64 ＋ ＝ f ． i64 ； return * this ； ｝ 
 　 　 　 　 fixed ＆ ＿ fastcalloperator * ＝ （ constfixed ＆ f ） 
 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ｛ i64 － ＝ f ． i64 ； return * this ； ｝ 
 　 　 　 　 　 fixed ＆ ＿ fastcalloperator * ＝ （ constfixed ＆ ） ； 
 　 　 　 　 　 fixed ＆ ＿ fastcalloperator ／ ＝ （ constfixed ＆ ） ； 
 　 　 　 　 　 fixed ＿ fastcalloperator ＋ （ constfixed ＆ f ） const 
 　 　 　 　 　 　 　 煟 鹒 ixedtmp （ * this ） ； tmp ． i64 ＝ i64 ＋ f ． i64 ； return 
 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 tmp ； ｝ 
 　 　 　 　 　 fixed ＿ fastcalloperator － （ constfixed ＆ f ） const 
 　 　 　 　 　 　 　 ｛ fixedtmp （ * this ） ； tmp ． i64 ＝ i64 － f ． i64 ； return 
 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 tmp ； ｝ 
 
 
 　 　 在 数值 运算 程序 的 开发 中 ， 希望 定点数 与 浮点数 的 使用 方法 完全相同 ， 所以 在 类 中 定义 了 这些 运算符 重载 的 成员 函数 ， 保证 了 使用 2 种数 的 C 代码 的 一致性 。 对 这些 成员 函数 的 实现 来说 ， 最大 问题 是 效率 ， 用 了 定点数 后 效率 大大 下降 是 不能 容许 的 。 解决 的 方法 是 大量 采用 inline 函数 ， 这种 函数 的 代码 直接插入 程序 ， 没有 调用 过程 ， 效率 很 高 ， 对 不能 用 inline 函数 实现 的 成员 函数 ， 采用 ＿ fastcall 关键字 来 加快 调用 进程 。 这 类 函数 只有 4 个 ： 定点数 和 浮点数 相互 转换 的 2 个 函数 以及 “ * ＝ ” 、 “ ／ ＝ ” 这 2 个 运算符 重载 函数 。 
 　 　 对于 定点数 和 浮点数 相互 转换 的 2 个 函数 ， 本文 在 3 种 浮点数 中 选择 longdouble ， 即 80387 中 的 临时 型 实数 来 做 相互 转换 ， 这样 选择 的 理由 是 ： 
 　 　 1 ． 临时 型 实数 的 精度 最高 ， 不会 因 转换 而 丢失 精度 。 
 　 　 2 ． 临时 型 实数 符号 位 和 指 数字 段 位数 相加 是 16 ， 即 正好 占 1 个 字 ， 使 指数值 的 修改 很 容易 。 
 　 　 3 ． 临时 型 实数 没有 隐藏 1 ， 可以 方便 地 判断 1 个数 是否 为 0 。 
 　 　 从 实现 上 说 ， 这 2 个 函数 的 实质 是 在 做 浮点数 和 整数 的 转换 ， 只不过 指数 部分 差 了 32 位 ， 由此 ， 可以 利用 80387 中 的 浮点数 和 整数 转换 的 指令 。 对 longdouble 类型 转化 为 fixed 类型 的 函数 ， 可以 先 将 被 转化 的 longdouble 数 指数 部分 加 32 ， 再用 fistp 指令 将 其 转化 为 64 位 整数 即可 。 在 这 中间 要 考虑 实数 为 零 的 情况 ， 因为 零 的 指数 必为 0 ， 若 指数 加 了 32 ， 就 成 了 伪 零 ［ 1 ］ ， 是 80387 所 不 支持 的 ， 会 引起 操作 异常 。 对 fixed 类型 转化 为 longdouble 类型 的 函数 ， 实现 方法 与 此 类似 ， 不再 赘述 。 
 　 　 对于 * ＝ 这个 运算符 重载 函数 ， 可以 先 将 1 个 64 位 整数 转化 为 临时 型 实数 ， 将 指 数字 段 减 32 ， 再 与 另 一个 64 位 整数 相乘 ， 就 得到 正确 结果 ， 其中 也 要 考虑 临时 型 实数 为 零 的 情况 。 对于 运算符 ／ ＝ 的 重载 函数 ， 实现 方法 也 与 此 相似 。 
 　 　 实际 测试 中 ， 乘法 的 速度 为 80387 指令 的 1 ／ 5 ， 加法 的 速度 为 80387 指令 的 1 ． 5 倍 ， 效率 能 令人满意 。 
 　 　 本文 设计 的 这种 高效 定点数 类 ， 应用 于 某 炼油厂 硫磺 回收 装置 仿真 培训 系统 的 数学模型 开发 中 ， 避免 了 80387 的 浮点 异常 ， 取得 了 良好 的 效果 。 
 朱丹 绯 （ 杭州 浙江大学 工业 控制技术 研究所 310027 ） 
 顾钟文 （ 杭州 浙江大学 工业 控制技术 研究所 310027 ） 
 周 春晖 （ 杭州 浙江大学 工业 控制技术 研究所 310027 ） 
 参考文献 
 1 ， 田云 ， 何德书 ， 宗耀堂 ． 保护方式 下 的 80386 及其 编程 ． 北京 ： 清华大学出版社 ， 1993 
 2 ， 张殿辉 ， 夏 四清 ． 计算机系统 浮点数 异常 的 处理 ． 小型 微型 计算机系统 ， 1996 ； 17 ( 4 ) 
 收稿 日期 ： 1999 － 08 － 16 
