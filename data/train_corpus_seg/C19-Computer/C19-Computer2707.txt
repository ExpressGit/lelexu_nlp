软件 学报 
 JOURNALOFSOFTWARE 
 1999 年 第 10 卷 第 12 期 Vol.10 No.121999 
 
 
 
 一个 交互式 的 Fortran77 并行 化 系统 
 陈 文光 　 杨 　 博 　 王紫瑶 　 郑丰宙 　 郑纬民 
 摘要 　 并行 化 编译器 可以 把 现有 的 串行 程序 自动 或 半自动 地 转换 为 并行程序 . 现有 并行 化 系统 的 自动 并行 化 效果 与 手工 并行 化 的 效果 相比 还有 一定 的 差距 ， 这是 由于 并行 化 工具 的 分析 能力 不足 以及 程序 中 所 固有 的 语义 信息 无法 被 并行 化 工具 所 理解 而 造成 的 . TIPS ( Tsinghuainteractiveparallelizingsystem ) 系统 通过 提供 一些 友好 的 交互式 工具 ， 使 用户 与 编译器 紧密 协作 ， 是 提高 并行 化 系统 的 能力 和 效率 的 一条 有效途径 . 
 关键词 　 并行 化 编译器 ， 交互式 系统 ， 相关性 查询 ， 增量 编译 , 性能 预测 . 
 中图法 分类号 　 TP311 
 AnInteractiveFortran77ParallelizingSystem 
 CHENWen - guangYANGBoWANGZi - yaoZHENGFeng - zhouZHENGWei - min 
 ( DepartmentofComputerScienceandTechnologyTsinghuaUniversityBeijing100084 ) 
 Abstract 　 Parallelizingcompilercantransformserialprogramstoparallelprogramsautomaticallyorsemi - automatically . Theup - to - dateautomaticparallelizingsystemscannotgenerateparallelcodesasgoodashandcodingformanyapplications . Themainreasonisthattheycannotmanipulatethecomplexitiesofrealapplications . What ' smore , therearesomesemanticinformationintheprogramthattheautomatictoolscanneverknowwithoutuser ' sknowledge . TIPS ( Tsinghuainteractiveparallelizingsystem ) providessomeuser - friendlyinteractivetoolssothatthecompilerandusercancooperatewitheachother . Itisaneffectivewaytoimprovethecapabilityandefficiencyofparallelizingcompiler . 
 Keywords 　 Parallelizingcompiler , interactivesystem , dependencequery , incrementalcompilation , performanceestimation . 
 　 　 从 80 年代 中期 开始 ， 随着 并行 计算机系统 的 发展 ， 人们 逐渐 开始 研究 串行 程序 并行 化 系统 . 最初 的 研究 是从 扩充 程序 的 自动 向 量化 系统 开始 的 ， 典型 的 例子 有 KAP 和 VAST . 但是 ， 在 实际 应用程序 中 ， 这些 自动 并行 化 系统 的 并行 化 效果 并 不 理想 ［ 1 ］ . 其 原因 在于 ， 自动 并行 化 与 自动 向 量化 有着 本质 的 区别 . 并行 化 需要 中 粗粒度 的 并行性 ， 而 向 量化 需要 细粒度 的 并行性 . 在 分析 粗粒度 并行性 时会 遇到 过程 调用 语句 和 符号 量 ， 使得 传统 的 相关性 分析方法 遭到 失败 . 
 　 　 近年来 ， 人们 在 并行 化 理论 和 实用 方法 两 方面 都 取得 了 一些 进展 ， 并 出现 了 一些 新 的 并行 化 系统 . 如 UIUC ( UniversityofIllinoisatUrbana - Champaign ) 的 Polaris ［ 2 , 3 ］ ， Stanford 大学 的 SUIF ( StanfordUniversityintermediateformat ) ［ 4 ］ ， 复旦大学 的 AFT ( automaticFortrantransformer ) ［ 5 ］ 等 . 
 　 　 这些 新一代 的 全自动 并行 化 工具 ， 通过 采用 过程 间 分析 、 符号 数据 相关性 分析 、 数组 私有化 、 归约 识别 、 复杂 形式 的 归纳 变量 识别 以及 运行 时 分析 等 新 技术 ， 并行 化 能力 与 KAP 等 传统 系统 相比 有 了 较大 提高 ， 对 某些 程序 的 并行 化 效果 已经 与 手工 并行 化 相近 . 但是 ， 还有 一些 程序 的 自动 并行 化 效果 与 手工 并行 化 的 效果 相比 还有 很大 差距 . 其 原因 在于 ， 在 全自动 并行 化 系统 中 使用 的 并行 化 算法 还 不能 有效 地 处理 这些 复杂 应用程序 . 除了 算法 本身 的 能力 不足 以外 ， 缺乏 有关 的 程序 语义 信息 更是 全自动 并行 化 算法 的 障碍 . 
 　 　 Greenwich 大学 的 CAPTools ［ 6 ～ 9 ］ ， Rice 大学 的 FortranD 系统 ［ 10 , 11 ］ 和 AppliedParallelResearch 公司 的 Forge90 等 均 是 交互式 的 并行 化 系统 . 
 　 　 这些 交互式 并行 化 系统 ， 在 尽可能 采取 自动 并行 化 技术 的 同时 ， 允许 人 在 并行 化 过程 中 查看 和 修改 并行 化 结果 ， 通过 利用 人 的 能力 来 提高 并行 化 效果 ， 在 部分 程度 上 弥补 了 全自动 并行 化 系统 的 不足 . 但是 ， 这些 交互式 的 工具 普遍 都 没有 采用 最新 的 自动 并行 化 技术 ， 因此 ， 它们 的 自动 并行 化 的 能力 比较 差 . 
 　 　 TIPS ( Tsinghuainteractiveparallelizingsystem ) 是 一个 交互式 的 并行 化 系统 ， 该 系统 以 Polaris 系统 为 基础 ， 具有 强大 的 自动 并行 化 底层 支持 . TIPS 具有 友好 的 交互 功能 ， 并 同时 支持 共享 存储系统 和 分布 存储系统 . 
 1TIPS 特点 与 结构 
 1.1 　 系统 特点 
 　 　 ( 1 ) 提供 友好 的 交互 手段 . 以 用户 容易 理解 的 方式 向 用户 显示 和 说明 并行 化 各个 阶段 的 结果 ， 紧密结合 用户 的 知识 ( 通过 向 用户 查询 ) ， 指导 进一步 的 并行 化 . 
 　 　 ( 2 ) 使用 先进 的 自动 并行 化 技术 . TIPS 是 基于 Polaris 开发 的 . Polaris 系统 中 采用 了 数组 私有化 、 归纳 变量 识别 、 归约 变量 识别 、 非线性 相关性 测试 、 符号分析 和 循环 变换 等 多项 最新 的 自动 并行 化 技术 . 但是 , 在 Polaris 系统 中 缺少 重要 的 过程 间 分析 技术 ， 而 我们 在 Polaris 系统 上 则 补充 了 过程 间 分析 模块 . 
 　 　 ( 3 ) 同时 支持 共享 存储系统 和 分布 存储系统 . 
 1.2 　 系统结构 
 我们 设计 的 用于 机群系统 的 Fortran77 程序 并行 化 系统 称做 TIPS , 其 结构 如图 1 所示 . 
 
 图 1 
 1.2 . 1 自动 并行 化 模块 
 　 　 自动 并行 化 模块 是 TIPS 系统 的 基础 ， 它 分为 以下 几 部分 . 
 　 　 ( 1 ) 过程 内 数据流 分析 
 　 　 过程 内 数据流 分析 为 相关性 分析 作 准备 . 该 阶段 进行 的 操作 包括 常数 传播 ( constantpropagation ) 、 标量 私有化 ( scalarprivatization ) 、 归纳 标量 识别 ( inductivevariablesrecognition ) 和 归约 识别 ( reductionrecognition ) 等 . 
 　 　 ( 2 ) 过程 间 分析 
 　 　 过程 间 分析阶段 进行 的 操作 包括 过程 繁衍 、 过程 间 数据流 分析 、 过程 间 数组 私有化 以及 过程 间 变换 等等 . 分析 出 的 过程 间 信息 可以 帮助 相关性 分析阶段 对 含有 过程 调用 的 循环 进行 并行 化 ， 也 是 增量 编译器 的 基础 . 
 　 　 ( 3 ) 数据 相关性 分析 
 　 　 只有 不 相关 的 语句 才 可以 在 没有 同步 的 情况 下 并行执行 ， 因此 相关性 分析 实际上 是 对 程序 并行性 的 识别 . 相关性 分析 通常 由 一系列 测试 来 完成 ， 在 TIPS 中 采用 的 测试 有 GCD ( greatestcommondivisor ) 测试 、 Banerjee 测试 、 Omega 测试 和 Range 测试 . 本 系统 中 扩展 了 Range 测试 ， 可以 把 一类 原先 无法 处理 的 相关性 问题 归结为 一些 不等式 ， 通过 交互 模块 向 用户 查询 ， 系统 根据 用户 的 回答 来 确认 循环 是否 可以 并行 化 . 
 1.2 . 2 并行 代码生成 模块 
 　 　 ( 1 ) 共享 代码生成 
 　 　 共享 代码生成 模块 根据 相关性 分析 、 私有化 和 规约 识别 等 模块 的 结果 ， 在 程序 中 插入 相应 的 指导 语句 ， 并 对 程序 进行 相应 的 变换 . 所 生成 的 并行 Fortran 程序 在 目标 机上 使用 本 机 编译器 就 可以 生成 并行 的 执行 代码 . 目前 ， 本 系统 的 共享 代码生成 模块 支持 SGIPowerChallengeSMP 系统 . 
 　 　 ( 2 ) 数据 和 计算 划分 分析 
 　 　 面向 分布 存储系统 的 程序 必须 显式 地 对 数据 和 计算 进行 划分 . 本 模块 的 主要 功能 是 对 数据 访问 模式 进行 分析 ， 尽量减少 并行程序 所 需 的 通信 次数 和 通信量 ， 从而 提高 并行程序 的 性能 . 
 　 　 ( 3 ) 分布 并行 代码生成 
 　 　 分布 并行 代码生成 就是指 利用 分析 出 的 并行性 以及 数据 和 计算 划分 方案 ， 进行 实际 的 数据 和 计算 划分 ， 然后 生成 通信 语句 . 在 并行 代码生成 时 把 相应 的 代码 插入 到 源程序 中 ， 生成 SPMD 的 结点 程序 ， 在 本 系统 中 生成 基于 PVM 的 并行 代码 . 并行 源代码 经过 串行 Fortran 编译器 编译 ， 生成 的 执行 代码 在 PVM 系统 的 支持 下 就 可以 进行 并行计算 了 . 
 1.2 . 3 交互 模块 
 　 　 交互 模块 负责 自动 并行 化 模块 与 用户 的 信息 交互 . 主要 任务 有 显示 并行 化 结果 、 向 用户 说明 该 并行 化 结果 的 原因 以及 向 用户 询问 程序 的 语义 信息 等 . 该 模块 的 主要 组成部分 如下 ： 
 　 　 ( 1 ) 调用 图 浏览器 
 　 　 显示 程序 的 调用 图 . 图中 的 结点 可以 是 循环 或 子程序 . 调用 图中 每个 结点 后 都 跟着 其 执行 时间 在 整个 程序 中所 占 的 比例 . 循环 节点 后 还 显示 该 循环 是否 可以 并行 ， 如果 是 串行 循环 ， 在 调用 图中 还 可以 显示 其 串行 的 原因 . 用户 仔细 查看 程序 后 ， 如果 认为 这些 原因 是 系统 能力 不足 所 造成 的 ， 可以 方便 地 强制 并行 化该 循环 . 
 　 　 调用 图 浏览器 与 交互 模块 的 其他 工具 紧密结合 ， 使 用户 可以 迅速 而 准确 地 了解 程序 的 概况 ， 并 可以 确定 程序 中 的 重要 部分 ( 运行 时间 长 ， 而且 无法 并行 的 循环 ) ， 进一步 对 程序 进行 深入 的 研究 . 
 　 　 ( 2 ) 增量 编译器 
 　 　 用户 在 使用 交互式 并行 化 工具 的 时候 ， 可能 会 对 程序 作 一些 修改 ， 如 手工 进行 一些 程序变换 等 . 由于 并行 化 系统 一般 执行 时间 比较 长 ， 如果 在 用户 对 程序 稍加 修改 后 还要 对 整个 程序 进行 完全 的 重新 编译 ， 会 浪费 用户 的 很多 时间 ， 降低 并行 化 的 效率 . 
 　 　 增量 编译器 通过 分析 ， 找出 用户 修改 所 影响 到 的 程序 单元 ， 并 只 对 这些 单元 进行 重新 编译 ， 从而 增强 了 系统 的 交互性 . 
 　 　 ( 3 ) 用户 知识 窗口 
 　 　 在 相关性 分析阶段 ， 对 一些 无法 解决 的 问题 ， 系统 提取 了 一些 不等式 . 在 用户 知识 窗口 中 ， 系统 向 用户 询问 这些 不等式 ， 用户 可以 回答 “ 成立 ” 、 “ 不 成立 ” 或 “ 不 一定 ” . 系统 根据 用户 的 回答 ， 确认 相应 的 循环 是否 可以 并行 化 . 
 　 　 对 用户 而言 ， 系统 所 询问 的 不等式 大多 很 容易 理解 ， 而且 不难 回答 ， 而 系统 通过 结合 用户 的 知识 ， 可以 得到 更好 的 并行 化 效果 . 
 　 　 ( 4 ) 相关 图 浏览器 
 　 　 相关 图 浏览器 显示 一个 循环 嵌套 的 相关 图 . 系统 提供 了 多种 过滤 方法 ， 使得 用户 可以 集中 于 对 某些 相关 问题 的 研究 . 
 　 　 ( 5 ) 程序运行 时间 预测器 
 　 　 程序运行 时间 预测器 可以 给出 每个 循环 的 运行 时间 在 整个 程序 中所 占 的 比例 . 这样 就 使得 用户 能够 集中精力 分析程序 中 那些 重要 的 部分 . 对 运行 时间 少 的 循环 ， 即使 它 不能 并行 化 也 不必 花费 太多 的 精力 . 
 　 　 对 程序运行 时间 进行 预测 有 动态 和 静态 两种 方法 . 动态 法 通过 在 源程序 中 加入 测量 时间 的 语句 并 实际 运行 程序 来 获得 运行 时间 . 静态 法 通过 分析程序 的 各种 操作 次数 ， 无需 运行 程序 就 可以 估计 出 程序 各 部分 的 运行 时间 . 动态 法 的 优点 是 比较 准确 ， 缺点 是 比较 费时 ( 如 程序 规模 比较 大时 ) ， 而且 有时候 无法 运行 程序 ( 例如 ， 缺少 输入 数据 ) . 使用 静态 法 可以 避免 上面 的 情况 . 一般来说 ， 静态 性能 预测 的 时间 与 程序 的 长度 成正比 ， 而 与 问题 的 规模 无关 ， 其 响应速度 比较 快 ， 但 准确性 稍差 . 
 　 　 在 本 系统 中 ， 我们 提供 了 动态 和 静态 两种 方法 . 用户 在 对 程序 的 运行 时间 进行 预测 时 ， 可以 根据 自己 的 需要 任选 一种 方法 . 
 　 　 ( 6 ) 程序 浏览器 
 　 　 程序 浏览器 使得 用户 可以 方便 地 浏览 源程序 和 并行 化 之后 的 程序 . 在 程序 浏览器 、 相关 图 浏览器 和 调用 图 浏览器 之间 有着 关联 关系 ， 在 任一 浏览器 中 选中 某一 循环 或 子程序 时 ， 其他 浏览器 的 内容 都 会 随之 同步 . 这 大大 方便 了 用户 对 程序 的 研究 和 分析 . 
 2 关键技术 
 2.1 　 交互技术 
 　 　 交互技术 是 交互式 系统 的 特色 ， 它 把 系统 的 各种 分析 算法 与 用户 结合 起来 ， 从而 形成 功能强大 的 并行 化 系统 . 要 让 用户 与 分析 算法 进行 有效 的 协作 ， 必须 能够 在 用户 和 算法 之间 有效 地 进行 双向 信息 流动 . 交互式 系统 使得 算法 的 并行 化 结果 可以 被 人 理解 ， 并 使得 人 所 提供 的 信息 可以 被 并行 化 算法 利用 . 另外 ， 交互式 系统 还 应该 对 用户 响应 时间 给予 一定 的 关注 ， 尽量减少 用户 操作 所 需 的 时间 ， 提高 用户 的 工作效率 . 
 　 　 具体地说 ， 在 并行 化 过程 中 ， 交互 模块 应该 能够 完成 下面 的 任务 . 
 　 　 ( 1 ) 向 用户 显示 并行 化 分析 结果 ( 用 相关 图 和 程序 调用 图 的 方式 ) . 用户 可以 查看 产生 某个 相关性 的 原因 ， 并且 可以 修改 相关 图 . 这 就 使得 用户 可以 考察 产生 相关性 的 程序段 . 用户 可能 发现 ， 这个 相关 实际上 是 由于 算法 能力 不足 而 造成 的 伪 相关 ， 因此 可以 直接 删除 该 相关 ； 也 可能 发现 ， 修改 ( 使用 某些 程序变换 技术 或 手工 重写 ) 该段 程序 可以 消除 相关 . 
 　 　 ( 2 ) 向 用户 提出 相关性 分析 算法 在 分析 中 所 无法 解决 的 一些 问题 ， 并 利用 用户 的 回答 来 改进 分析 结果 . 由于 所 提出 问题 的 数量 有 可能 十分 巨大 ， 所以 要 特别 注意 问题 的 选择 . 需要 提出 的 是 出现 次数 较 多 的 问题 ， 因为 这 类 问题 对 并行 化 效果 的 影响 可能 较大 . 
 　 　 ( 3 ) 提供 程序 各 部分 运行 时间 之 比 ， 使 用户 可以 把 注意力 集中 在 并行 化 的 关键步骤 上 . 
 　 　 ( 4 ) 增量 编译 功能 ， 即 在 用户 修改 了 程序 之后 只 对 受到 影响 的 程序 单元 进行 重新 编译 ， 而 无需 对 整个 程序 进行 重新 编译 . 
 　 　 ( 5 ) 程序 浏览 功能 ， 该 功能 可以 帮助 用户 方便 地 找到 所 要 分析 的 程序段 ( 如 运行 时间 最长 的 循环 ， 或者 含有 相关 的 循环 ) . 
 　 　 程序 浏览 功能 、 相关 图 和 程序 调用 图 显示 等 功能 所 需 的 技术 比较简单 ， 限于 篇幅 ， 在 本文 中 略去 . 对 交互技术 中 3 项 比较复杂 的 技术 ： 增量 编译 技术 、 静态 程序 性能 预测 技术 和 相关性 查询 技术 ， 下面 作 一个 简单 介绍 . 
 2.1 . 1 增量 编译 技术 
 　 　 在 TIPS 系统 中 的 增量 编译器 是 以 子程序 为 编译 单位 的 . 其 基本原理 是 ： 增量 编译器 通过 分析 源程序 得到 了 一些 过程 内 和 过程 间 信息 ( 用 一些 集合 表示 ) . 当 用户 修改 了 程序 后 ， 增量 编译器 首先 通过 比较 找出 修改 了 的 程序 单元 ， 通过 重新 计算 这些 集合 ， 可以 找出 受到 本次 修改 影响 的 其他 程序 单元 . 这些 程序 单元 将 被 重新 编译 . 
 2.1 . 2 静态 程序 性能 预测 技术 
 　 　 本 系统 中 静态 程序 性能 预测 技术 的 基本 思想 是 ： 预先 在 目标 机上 运行 一些 基准 程序 ， 获得 一些 基本操作 ( 如 + , - , * , / , ... ) 的 开销 ； 在 预测 一个 程序 的 性能 时 ， 统计 该 程序 内部 各种 基本操作 的 个数 ， 程序运行 的 时间 就是 这些 基本操作 所 需 时间 之 和 . 
 　 　 由于 没有 考虑 有关 存储器 层次 的 信息 ( 寄存器 、 Cache 和 内存 的 访问 时间 的 差异 ) ， 可能 会 导致 性能 预测 和 实际 运行 的 结果 有 很大 的 差异 . 若要 解决 这个 问题 ， 需 根据 程序 的 执行 过程 模拟 存储器 的 行为 ， 这样 做 ， 开销 过大 . 但是 在 TIPS 系统 中 ， 使用 静态 程序 性能 预测 的 目的 并 不是 为了 得到 准确 的 执行 时间 ， 而是 为了 得到 程序 各个 部分 的 相对 执行 时间 和 整个 程序 的 复杂程度 ， 因此 这种 性能 预测 技术 在 我们 的 系统 中是 适用 的 . 
 　 　 我们 的 性能 预测 算法 包括 训练 集 的 构造 和 测试 、 语法分析 和 时间 预测 计算 这 3 部分 . 
 　 　 通过 构造 和 运行 训练 集 ， 可以 获取 基本操作 和 内部 函数 在 目标 机上 的 运行 时间 . 语法分析 阶段 的 功能 是 分析 源程序 并 构造 抽象 语法 树 ， 对 程序 进行 相应 的 变换 ， 以便 进行 后面 的 分析 . 时间 计算 模块 根据 上面 两个 模块 的 结果 来 计算 时间 . 
 2.1 . 3 相关性 查询 技术 
 　 　 相关性 查询 可以 简单 地 把 不能 解决 的 相关 问题 都 保守 地 估计 为 相关 ， 输出 相关 图 ， 然后 由 用户 自己 来 分析程序 ， 手工 消除 不 存在 的 相关 关系 ， 从而 达到 并行 化 的 目的 . 本 系统 也 提供 了 这种 功能 . 但是 ， 这种 方法 对 用户 而言 不够 友好 ， 因为 相关 关系 的 分析 有时 并 不 那么 直接 ， 而且 程序 中 相关 的 数目 众多 ， 用户 难以 分清 哪些 是 真 相关 ， 哪些 是 假 的 相关 . 
 　 　 我们 扩展 了 Range 测试 的 思想 ， 对 一类 无法 解决 的 相关性 问题 抽取 出 一些 不等式 ， 然后 向 用户 查询 这些 不等式 是否 成立 ， 通过 用户 的 回答 来 确定 相关 是否 存在 . 这种 方法 的 优点 在于 既 增加 了 查询 本身 的 友好 性 ， 又 减少 了 用户 所 需 分析 的 代码 的 范围 ， 可以 把 人 的 能力 很 好 地 结合 进 并行 化 过程 中 . 
 　 　 下面 ， 我们 介绍 不等式 的 提取 算法 . 
 　 　 由 Range 测试 可知 ， 在 下面 的 程序 中 ， 若 jn ≤ N ， 则 i 循环 可以 并行 . 
 　 　 doi = 1 , in 
 　 　 　 　 doj = 1 , jn 
 　 　 　 　 　 　 A ( i * N + j ) = ... 
 　 　 　 　 　 　 ... = A ( i * N + j ) 
 　 　 　 　 enddo 
 　 　 enddo 
 　 　 当 系统 无法 确定 jn ≤ N 是否 可以 并行 时 ， 就 可以 生成 一个 不等式 ， 每个 不等式 对应 于 一个 相关 弧 . 在 实际 系统 中 ， 通常 对 下标 表达式 进行 一些 变换 ， 因此 提出 的 问题 可能 不像 上面 的 程序 那么 直接 ， 但是 问题 仍然 是 容易 理解 和 回答 的 . 
 　 　 对 循环 中 的 每 一对 符合 上述 条件 的 相关 产生 了 不等式 后 ， 需要 以 循环 为 单位 对 这些 不等式 进行 归结 . 最后 以 循环 为 单位 ， 向 用户 查询 . 
 　 　 例如 ， PerfectBenchmark 中 的 程序 APSI 中有 这样 的 程序段 ： 
 　 　 IPP2 = IP + 2 
 　 　 IPPH = ( IP + 1 ) / 2 
 　 　 
 　 　 DOJ = 2 , IPPH 
 　 　 　 　 JC = IPP2 - J 
 　 　 　 　 J2 = J + J 
 　 　 　 　 DOK = 1 , L1 
 　 　 　 　 　 　 CH ( 1 , K , J ) = CC ( IP0 , J2 - 2 , K ) + CC ( IP2 , J02 , K ) 
 　 　 　 　 　 　 CH ( 1 , K , JC ) = CC ( 1 , J2 - 1 , K ) + CC ( 1 , J2 - 1 , K ) 
 　 　 　 　 ENDDO 
 　 　 ENDDO 
 　 　 系统 可以 抽取 出 两个 不等式 ， 只要 其中 一个 成立 ， 就 可以 确定 该 循环 是 并行 的 . 
 　 　 ( 1 ) IP < 2 
 　 　 ( 2 ) 2 + IP > 2 * IPPH 
 　 　 用户 通过 IPPH ＝ ( IP + 1 ) / 2 可以 很 容易 知道 不等式 ( 2 ) 成立 ， 从而 并行 化 循环 J . 从 这个 例子 可以 看出 ， 本 方法 提出 的 问题 对 用户 来讲 ， 非常容易 理解 ， 也 比较 容易 回答 . 用户 甚至 不 需要 有 相关性 分析 的 知识 就 可以 帮助 系统 进行 并行 化 . 
 　 　 类似 的 循环 ， 在 PerfectBenchmark 中 还有 很多 . 我们 初步 分析 了 13 个 PerfectBenchmark 中 的 10 个 程序 ， 其中 有 5 个 程序 可以 提出 有效 的 问题 . 因此 可以 认为 ， 本 方法 具有 一定 的 普遍 适用性 . 
 2.2 　 过程 间 分析 技术 
 　 　 过程 间 分析 技术 是 一项 十分 重要 的 技术 ， 它 使得 含有 过程 调用 不再 成为 并行 的 障碍 ， 也 避免 了 过程 嵌入 所 带来 的 代码 爆炸 现象 . 在 TIPS 系统 中 ， 过程 间 分析 还是 增量 编译器 的 基础 . 本 系统 中 实现 的 过程 间 分析 技术 主要 包括 过程 间 数据流 分析 、 过程 间 相关性 分析 、 过程 间 私有化 和 循环 嵌入 等 . 限于 篇幅 ， 本文 略去 了 过程 间 分析 的 算法 . 
 2.3 　 分布 并行 代码生成 技术 
 　 　 TIPS 系统 的 分布 并行 代码生成 模块 按 并行执行 模型 把 程序 划分 为 若干 区 ( region ) ： 
 　 　 　 　 Region1 
 　 　 　 　 ... 
 　 　 　 　 Region2 
 　 　 　 　 ... 
 　 　 　 　 RegionN 
 　 　 Region 可以 是 一个 并行 循环 ， 也 可以 是 一段 串行 程序 ， Region 内部 没有 通信 ， Region 之间 在 需要 的 情况 下 可以 进行 通信 以 获得 计算所 需 的 数据 或是 计算结果 . 一般而言 ， 在 并行 Region 结束 后要 进行 全局 数据 同步 ， 这样 , 每个 Region 在 开始 执行 的 时候 都 拥有 全部 正确 的 数据 . 对 并行 循环 来说 ， 系统 通过 划分 循环 实例 空间 来 进行 计算 划分 ， 在 多个 结点 上 并行执行 . 数据 空间 没有 直接 划分 ， 各 结点 都 拥有 完整 的 数据 空间 . 这样 做 的 好处 是 消除 了 地址变换 操作 和 缓冲区 管理 ， 方便 了 串行 程序执行 ， 缺点 则 是 占用 内存 比较 大 . 程序 的 串行 部分 由 各个 节点 进行 冗余 执行 ， 从而 减少 了 串行 执行 所 带来 的 通信 开销 . I / O 操作 由于 是 在 串行 部分 完成 的 ， 也 是 由 各个 结点 冗余 执行 的 ， 这样 就 减少 了 由 主控 结点 读入 数据 再 进行 分发 的 通信 开销 . 
 　 　 TIPS 分布 代码生成 模块 采用 的 技术 包括 数据 对准 分析 、 临时 数组 消除 、 通信 合并 等 ， 目前 可以 生成 PVM + F77 代码 . 限于 本文 的 篇幅 ， 我们 略去 这些 算法 . 
 3 性能 测试 
 3.1 　 静态 性能 预测器 性能 测试 
 　 　 为了 测试 估计 器 的 性能 ， 我们 进行 了 一系列 的 测试 . 所有 的 实验 都 是 在 一台 拥有 双 CPU 的 Ultra2 上 进行 的 ， 操作系统 是 Solaris2.5 . 
 3.1 . 1 准确性 测试 
 　 　 我们 使用 了 普渡大学 的 一系列 程序 对 该 预测器 的 估计 准确性 进行 了 测试 ， 虽然 这些 例子 比较 短小 ， 但是 也 反映 了 实际 应用程序 的 特点 . 结果 如表 1 所示 . 
 表 1 准确性 测试 结果 
 
 程序 实测 时间 ( s ) 预测 时间 ( s ) ( 预测 - 实测 ) / 实测 * 100 ( % ) 
 problem01 . f1.441 . 589.7 
 problem02 . f0.460 . 460 
 problem03 . f6.423 . 57 - 44.4 
 problem04 . f3.874 . 4515.0 
 problem05 . f3.622 . 71 - 25.2 
 problem07 . f1.861 . 82 - 2.2 
 problem08 . f1.390 . 79 - 43.2 
 problem09 . f0.940 . 55 - 41.5 
 
 　 　 通过 上面 的 实验 可以 看出 ， 估计 的 误差 局限 在 - 50% ～ 20% 之间 . 在 通常 情形 下 ， 估计值 将 小于 实际 的 运行 时间 ， 这 主要 是 由于 存储器 访问 的 不确定性 引起 的 . 由于 训练 模块 通过 多次 迭代 的 方法 得到 操作 的 平均 执行 时间 ， 因此 ， 存储器 的 访问 基本上 是 对 Cache 进行 的 . 而 对于 实际 的 应用程序 来说 ， 在 Cache 不 命中 的 情况 下 ， 需要 从 内存 或者 甚至 外存 进行 调页 ， 因此 其 实际 的 执行 时间 将 大于 预测 的 时间 . 如果 在 一个 应用程序 中 ， 当 用于 计算 的 时间 比 用于 内存 访问 的 时间 大得多 时 ， 预测 的 结果 将会 比较 准确 . 
 3.1 . 2 确定 重要 循环 
 　 　 性能 预测 可以 指导 用户 将 注意力 集中 在 一些 比较 耗时 的 循环 上 ， 尽量 将 这些 循环 进行 并行 化 ， 以 更 大地 提高 加速 比 . 在 静态 预测 时 ， 有时 虽然 总 的 预测 时间 与 实测 时间 相差 较大 ， 但是 程序 中 各 部分 所 占 比例 的 差别 却 不是 很大 . 我们 以 purdue - set 中 的 problem09 . f 各 循环 占 全部 程序运行 时间 的 比例 为例 ， 见表 2 . 
 表 2 　 各个 循环 预测 和 实测 的 运行 时间 所 占 比例 的 比较 
 
 循环 实测 时间 ( s ) 比例 ( % ) 预测 时间 ( s ) 比例 ( % ) 
 DOITdo # 10.211210 . 13424 
 DOITdo400.310310 . 23743 
 DOITdo500.00100 . 0010 
 DOITdo600.305300 . 13024 
 DOITdo750.118120 . 0468 
 
 　 　 从 上面 的 结果 可以 看出 ， 实测 和 预测 的 结果 在 换算 为 各个 循环 所 占 的 比例 后 相差 较 小 ， 因此 , 使用性能 预测 可以 很 好 地 确定 重要 的 循环 ， 指导 应用程序 的 并行 化 . 
 3.2 　 分布 代码生成 性能 测试 
 　 　 我们 测试 了 purdue - set 中 14 个 Benchmark 程序 在 全自动 并行 后 再 进行 自动 分布 代码生成 的 性能 ， 运行 环境 是 8 台带 2 个 CPU 的 SunUltra2 ， 操作系统 是 Solaris2.5 ， 使用 100M 共享 以太网 连接 . 串行 运行 时间 是 在 1 个 CPU 下 运行 的 时间 ， 并行 运行 时间 是 在 8 台 工作站 上 使用 8 个 CPU 运行 的 时间 . 因为 这些 问题 的 运行 时间 都 比较 短 ， 我们 把 每个 问题 运行 10 次取 平均值 作为 其 执行 时间 ， 结果 见表 3 . 
 表 3 　 分布式 代码生成 的 测试 结果 
 
 程序 串行 运行 时间 ( s ) 8 结点 并行 运行 时间 ( s ) 加速 比 说明 
 Problem01 . f3.00 . 74.29 　 
 problem02 . f6.41 . 34.92 　 
 problem03 . f20.73 . 85.45 　 
 problem04 . f — — — 结果 不 正确 
 problem05 . f1.38 . 20.159 　 
 problem06 . f501700.185 　 
 problem07 . f1.82 . 00.9 　 
 problem08 . f0.570 . 07 　 
 problem09 . f — — — 编译 未 通过 
 problem11 . f — — — 编译 未 通过 
 problem12 . f0.4 — — 并行 后 运行 时间 过长 
 problem13 . f2.10 . 63.5 　 
 problem14 . f — — — 未 发现 并行性 
 problem15 . f — — — 编译 未 通过 
 
 　 　 在 上述 测试 结果 中 ， “ 编译 未 通过 ” 是因为 我们 使用 的 底层 自动化 编译器 Polaris 不能 顺利 编译 这些 测试程序 . 可以 看出 ， 对 某些 程序 ， TIPS 分布 代码生成 模块 可以 生成 满意 的 并行 代码 ， 但是 对 另 一些 程序 ， 生成 的 并行 代码 效率 很 低 ， 甚至 不 正确 . 这 是因为 分布 代码生成 模块 生成 的 通讯 过多 ， 或是 没有 考虑 到 某些 特殊 情况 造成 的 . 
 3.3 　 增量 编译器 性能 测试 
 　 　 由于 增量 编译器 是 在 用户 修改 程序 后 进行 重新 编译 ， 因此 用户 修改 程序 的 方式 会 极大 地 影响 增量 编译器 的 性能 . 为此 ， 我们 只 进行 了 简单 的 测试 ， 测试 结果表明 ， 修改 程序 中 的 一个 循环 界后 采用 增量 编译器 比 完全 重新 编译 大约 减少 50% 的 编译 时间 . 
 4 将来 的 工作 
 　 　 我们 计划 在 以下 几个 方面 进行 更加 深入 的 研究 . 
 　 　 。 静态 性能 预测 . 静态 性能 预测 目前 不够 准确 ， 其 主要 原因 是 循环 界 估计 不 准确 和 未 考虑 cache 的 影响 . 我们 计划 采用 动态 / 静态 结合 或是 向 用户 查询 的 方法 获得 更加 精确 的 循环 界值 . 对于 cache 的 影响 ， 我们 正在 评估 各种 能够 处理 cache 的 性能 模型 . 
 　 　 。 查询 . 在 目前 的 TIPS 中 ， 系统 只 对 一类 Range 测试 不能 解决 的 相关 问题 进行 查询 . 我们 计划 扩展 查询 的 使用 范围 ， 包括 考察 其他 适用 于 查询 的 相关性 测试 算法 ， 或 把 查询 技术 应用 于 数组 私有化 、 分布 代码生成 等 方面 . 
 　 　 。 增量 编译 . 我们 将 考察 用户 修改 程序 的 模式 ， 并 针对 这些 模式 作 特殊 的 处理 ， 以 达到 更快 的 增量 编译 速度 . 
 　 　 。 分布 代码生成 器 . 目前 生成 的 分布 代码 在 每个 结点 上 都 拥有 全局 数据 ， 因此 不适 用于 需要 内存 较大 的 程序 . 我们 将 采用 新 的 分布 程序 模型 ， 使得 每个 结点 可以 拥有 小于 全局 数据 空间 的 局部 数据 空间 . 同时 ， 我们 还要 研究 通信 优化 算法 ， 并 加强 系统 的 稳定性 . 
 5 小结 
 　 　 我们 认为 ， 交互式 系统 是 进行 提高 并行 化 质量 的 一个 有 前途 的 方向 . TIPS 系统 以 最新 的 自动 并行 化 编译器 为 基础 ， 开发 了 友好 的 交互 工具 ， 可以 有效 地 帮助 用户 进行 程序 并行 化 工作 . 
 * 本文 研究 得到 国家 863 高科技 项目 基金 资助 . 
 作者简介 ： 陈 文光 , 1972 年生 , 博士 , 主要 研究 领域 为 并行 编译 技术 . 
 　 　 　 　 　 杨博 , 1976 年生 , 博士生 , 主要 研究 领域 为 并行 编译 ， 网络 计算 . 
 　 　 　 　 　 王紫瑶 , 女 ， 1974 年生 , 硕士 , 主要 研究 领域 为 并行 编译 . 郑丰宙 , 1976 年生 , 硕士生 , 主要 研究 领域 为 并行 编译 ， 网络 计算 . 
 　 　 　 　 　 郑纬民 , 1946 年生 , 教授 ， 博士生 导师 , 主要 研究 领域 为 并行 分布 处理 . 
 本文 通讯联系 人 : 杨博 ， 北京 100084 , 清华大学 计算机科学 与 技术 系 系统 应用 教研组 
 作者 单位 ： 清华大学 计算机科学 与 技术 系 　 北京 　 100084 
 E - mail : yangbo @ est4 . cs . tsinghua . edu . cn 
 参考文献 
 　 　 1 　 BlumeWilliam , EigenmannRudolf . Performanceanalysisofparallelizingcompilersontheperfectbenchmarksprograms . IEEETransactionsonParallelandDistributedSystems , 1992 , 3 ( 6 ) : 643 ～ 656 
 　 　 2 　 BlumeWilliam , DoalloRamonetal . Parallelprogrammingwithpolaris . Computer , 1996 , 29 ( 12 ) : 78 ～ 82 
 　 　 3 　 BlumeWilliam , DoalloRamonetal . AdvancedProgramRestructuringforHigh - PerformanceComputerswithPolaris . TechnicalReport , 1473 , UniversityofIllinoisatUrbana - Champaign , CenterforSupercomputingResearch & Development , 1996 
 　 　 4 　 AmarasingheSP , AndersonJMetal . TheSUIFcompilerforscalableparallelmachines . In : BaileyDH , GilbertJR , MascagniMetaleds . Proceedingsofthe7thSIAMConferenceonParallelProcessingforScientificComputing . Philadelphia : SocietyforIndustrialandAppliedMathematics , 1995 
 　 　 5 　 朱传琪 , 臧斌宇 , 陈彤 . 程序 自动 并行 化 系统 . 软件 学报 , 1996 , 7 ( 3 ) : 180 ～ 186 
 ( ZhuChuan - qi , ZangBin - yuChenTong . Anautomaticparallelizer . JournalofSoftware , 1996 , 7 ( 3 ) : 180 ～ 186 ) 
 　 　 6 　 IerotheouCS , Johnsonetal . Computeraidedparallelizationtools ( CAPTools ) — — conceptualoverviewandperformanceontheparallelizationofstructuredmeshcodes . ParallelComputing , 1996 , 22 ( 2 ) : 163 ～ 195 
 　 　 7 　 JohnsonSP , IerotheouCSetal . Automaticparallelcodegenerationformessagepassingondistributedmemorysystems . ParallelComputing , 1996 , 22 ( 2 ) : 227 ～ 258 
 　 　 8 　 JohnsonSP , CrossMetal . Exploitationofsymbolicinformationininterproceduraldependenceanalysis . ParallelComputing , 1996 , 22 ( 2 ) : 197 ～ 226 
 　 　 9 　 LeggettPF , MarshATJetal . IntegratinguserknowledgewithinformationfromparallelizationtoolstofacilitatetheautomaticgenerationofefficientparallelFORTRANcode . ParallelComputing , 1996 , 22 ( 2 ) : 259 ～ 288 
 　 10 　 HiranandaniSeema , KennedyKenetal . CompileroptimizationforFortranDonMIMDdistributed - memorymachines . In : ProceedingsoftheSupercomputing ' 91 . Washington , DC : IEEE , ACM , 1991.86 ～ 100 
 　 11 　 HiranandaniSeema , KennedyKenetal . TheDeditor : anewinteractiveparallelprogrammingtool . In : ProceedingsoftheSupercomputing ' 94 . Washington , DC : IEEE , ACM , 1994.733 ～ 742 
 本文 1998 - 11 - 06 收到 原稿 , 1999 - 02 - 01 收到 修改稿 
